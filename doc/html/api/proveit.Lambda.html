
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Lambda &#8212; Prove-It 0.3 documentation</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="LambdaApplicationError" href="proveit.LambdaApplicationError.html" />
    <link rel="prev" title="Label" href="proveit.Label.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="lambda">
<h1>Lambda<a class="headerlink" href="#lambda" title="Permalink to this headline">¶</a></h1>
<dl class="py class">
<dt id="proveit.Lambda">
<em class="property">class </em><code class="sig-prename descclassname">proveit.</code><code class="sig-name descname">Lambda</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">parameter_or_parameters</span></em>, <em class="sig-param"><span class="n">body</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/proveit/_core_/expression/lambda_expr/lambda_expr.html#Lambda"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#proveit.Lambda" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="proveit.Expression.html#proveit.Expression" title="proveit._core_.expression.expr.Expression"><code class="docutils literal notranslate"><span class="pre">proveit.Expression</span></code></a></p>
<p>A lambda-function Expression.  A lambda function maps parameter(s) to
its body.  For example, (x, y) -&gt; sin(x^2 + y), where (x, y) are the
parameters and sin(x^2 + y) is the body.  Each parameter must be a
Variable.  Note that the body of a Lambda may be a Conditional
such that the mapping is only defined when one of the conditions is
satisfied.</p>
<p class="rubric">Methods Summary</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#proveit.Lambda.apply" title="proveit.Lambda.apply"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply</span></code></a>(self, \*operands[, …])</p></td>
<td><p>Apply this lambda map onto the given operands (a beta reduction in the lambda calculus terminology), returning the expression that results from applying the map.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#proveit.Lambda.compose" title="proveit.Lambda.compose"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compose</span></code></a>(self, lambda2)</p></td>
<td><p>Given some x -&gt; f(x) for self (lambda1) and y -&gt; g(y) for lambda2, return x -&gt; f(g(x)).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#proveit.Lambda.extract_argument" title="proveit.Lambda.extract_argument"><code class="xref py py-obj docutils literal notranslate"><span class="pre">extract_argument</span></code></a>(self, mapped_expr)</p></td>
<td><p>Given a mapped expression, return the argument that will transform this Lambda expression into the mapped expression.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#proveit.Lambda.extract_arguments" title="proveit.Lambda.extract_arguments"><code class="xref py py-obj docutils literal notranslate"><span class="pre">extract_arguments</span></code></a>(self, mapped_expr)</p></td>
<td><p>Given a mapped expression, return the arguments that will transform this Lambda expression into the mapped expression.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#proveit.Lambda.global_repl" title="proveit.Lambda.global_repl"><code class="xref py py-obj docutils literal notranslate"><span class="pre">global_repl</span></code></a>(master_expr, sub_expr[, assumptions])</p></td>
<td><p>Returns the Lambda map for replacing the given sub-Expression everywhere that it occurs in the master Expression.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#proveit.Lambda.latex" title="proveit.Lambda.latex"><code class="xref py py-obj docutils literal notranslate"><span class="pre">latex</span></code></a>(self, \*\*kwargs)</p></td>
<td><p>Return a latex-formatted representation of the Expression.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#proveit.Lambda.relabeled" title="proveit.Lambda.relabeled"><code class="xref py py-obj docutils literal notranslate"><span class="pre">relabeled</span></code></a>(self, relabel_map)</p></td>
<td><p>Return a variant of this Lambda expression with one or more of its parameter labels changed.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#proveit.Lambda.remake_arguments" title="proveit.Lambda.remake_arguments"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remake_arguments</span></code></a>(self)</p></td>
<td><p>Yield the argument values or (name, value) pairs that could be used to recreate the Lambda expression.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#proveit.Lambda.string" title="proveit.Lambda.string"><code class="xref py py-obj docutils literal notranslate"><span class="pre">string</span></code></a>(self, \*\*kwargs)</p></td>
<td><p>Return a string representation of the Expression.</p></td>
</tr>
</tbody>
</table>
<p class="rubric">Methods Documentation</p>
<dl class="py method">
<dt id="proveit.Lambda.apply">
<code class="sig-name descname">apply</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">\*operands</em>, <em class="sig-param">equiv_alt_expansions=None</em>, <em class="sig-param">allow_relabeling=False</em>, <em class="sig-param">assumptions=None</em>, <em class="sig-param">requirements=None</em>, <em class="sig-param">equality_repl_requirements=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/proveit/_core_/expression/lambda_expr/lambda_expr.html#Lambda.apply"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#proveit.Lambda.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply this lambda map onto the given operands (a beta reduction
in the lambda calculus terminology), returning the
expression that results from applying the map.  Assumptions
may be necessary to prove requirements that will be passed back
if a requirements list is provided.  Requirements may be needed
to ensure that operands are an appropriate length to match
a corresponding ExprRange of parameters.  Specifically, the Len
of an ExprTuple containing the operands must equal the Len of an
ExprTuple containing the range of indices covered by a
corresponding parameter range (see the example below).  Full
automation of the  length proof will only be performed for the
last parameter entry; proving the length equivalence may need to
be performed in advance.</p>
<p>For example, applying the Lambda
(x, y_1, …, y_3, z_i, …, z_j) -&gt;</p>
<blockquote>
<div><p>x*y_1 + … + x*y_3 + z_i + … + z_j</p>
</div></blockquote>
<p>to operands (a, b, c, d, e_m, …, e_n, f)
will result in a*b + a*c + a*d + e_m + … _ e_n + f provided
that|(b, c, d)| = <a href="#id1"><span class="problematic" id="id2">|(1, ..., 3)|</span></a> is proven in advance and that
<a href="#id3"><span class="problematic" id="id4">|(e_m, ..., e_n, f)|</span></a> = <a href="#id5"><span class="problematic" id="id6">|(i, ..., j)|</span></a> can be proven via
automation.</p>
<p>A dictionary may be provided for equiv_alt_expansions to
accomplish instantiation of ranges of parameters with more
versatility.  For example, given the following Lambda
(x_1, …, x_{n+1}) -&gt; (x_1 &lt; x_{1+1}) and …</p>
<blockquote>
<div><p>and (x_n &lt; x_{n+1})</p>
</div></blockquote>
<dl class="simple">
<dt>we can apply this on the following operands:</dt><dd><p>(a_1, …, a_{k+1}, b_1, …, b_{n-k})</p>
</dd>
</dl>
<p>along with the following entries in equiv_alt_expansions
(x_1, …, x_n, x_{n+1}) :</p>
<blockquote>
<div><p>(a_1, …, a_k, a_{k+1}, b_1, …, b_{n-k-1}, b_{n-k})</p>
</div></blockquote>
<dl class="simple">
<dt>(x_1, x_{1+1}, …, x_{n+1}) :</dt><dd><dl class="simple">
<dt>(a_1, a_{1+1}, …, a_{k+1}, b_1,</dt><dd><p>b_{1+1}, …, b_{(n-k-1)+1})</p>
</dd>
</dl>
</dd>
</dl>
<p>to obtain
(a_1 &lt; a_{1+1}) and … and (a_k &lt; a_{k+1}) and a_k &lt; b_1</p>
<blockquote>
<div><p>and (b_1 &lt; b_{1+1}) and … and (b_{n-k-1} &lt; b_{(n-k-1)+1})</p>
</div></blockquote>
<p>under the following requirements:
<a href="#id7"><span class="problematic" id="id8">|(a_1, ..., a_{k+1}, b_1, ..., b_{n-k})|</span></a> = <a href="#id9"><span class="problematic" id="id10">|(1, ..., n+1)|</span></a>
(1, …, n) = (1, …, n, n+1)
(1, …, n) = (1, 1+1, …, n+1)
(a_1, …, a_{k+1}, b_1, …, b_{n-k})</p>
<blockquote>
<div><p>= (a_1, …, a_k, a_{k+1}, b_1, …, b_{n-k-1}, b_{n-k})</p>
</div></blockquote>
<dl class="simple">
<dt>(a_1, …, a_{k+1}, b_1, …, b_{n-k})</dt><dd><dl class="simple">
<dt>= (a_1, a_{1+1}, …, a_{k+1}, b_1,</dt><dd><p>b_{1+1}, …, b_{(n-k-1)+1})</p>
</dd>
</dl>
</dd>
<dt><a href="#id11"><span class="problematic" id="id12">|({a_1, ..., a_k, a_{k+1}, b_1, ..., b_{n-k-1})|</span></a></dt><dd><p>= <a href="#id13"><span class="problematic" id="id14">|(1, ..., n)|</span></a></p>
</dd>
<dt><a href="#id15"><span class="problematic" id="id16">|(a_{1+1}, ..., a_{k+1}, b_1, b_{1+1}, ..., b_{(n-k-1)+1})|</span></a></dt><dd><p>= <a href="#id17"><span class="problematic" id="id18">|(1+1, ..., n+1)|</span></a></p>
</dd>
</dl>
<p>If allow relabeling is True then inn</p>
<p>There are limitations with respect the Lambda map application
involving parameter ranges when perfoming operation
substitution in order to keep derivation rules (i.e.,
instantiation) simple.  For details, see the
ExprRange.replaced documentation.</p>
<p>There may be additional requirements introduced when expanding
ranges.  For example, indices may need to match, not just
lengths.  Also, we may perform automatic equality replacement
in the process of performing the lambda application.  For
example, “And() = TRUE”.  Any employed replacements will be
added to the requirements list and added to the
‘equality_repl_requirements’ set (if one is provided).</p>
</dd></dl>

<dl class="py method">
<dt id="proveit.Lambda.compose">
<code class="sig-name descname">compose</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">lambda2</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/proveit/_core_/expression/lambda_expr/lambda_expr.html#Lambda.compose"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#proveit.Lambda.compose" title="Permalink to this definition">¶</a></dt>
<dd><p>Given some x -&gt; f(x) for self (lambda1) and y -&gt; g(y) for lambda2,
return x -&gt; f(g(x)).  Also works with multiple parameters:
x1, x2, …, xn -&gt; f(x1, x2, …, xn)  for lambda 1 and
y1, y2, …, yn -&gt; g1(y1, y2, …, yn),
y1, y2, …, yn -&gt; g2(y1, y2, …, yn),
…
y1, y2, …, yn -&gt; gn(y1, y2, …, yn) for lambda2 returns
x1, x2, …, xn -&gt; f(g1(x1, x2, …, xn), g2(x1, x2, …, xn), …, gn(x1, x2, …, xn)).</p>
</dd></dl>

<dl class="py method">
<dt id="proveit.Lambda.extract_argument">
<code class="sig-name descname">extract_argument</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">mapped_expr</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/proveit/_core_/expression/lambda_expr/lambda_expr.html#Lambda.extract_argument"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#proveit.Lambda.extract_argument" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a mapped expression, return the argument that will transform
this Lambda expression into the mapped expression.  For example,
if the Lambda expression is x -&gt; x + 1 and the mapped expression
is 2 + 1, this will return 2.  If there is more than one parameter
in this Lambda expression, use extract_arguments instead.</p>
</dd></dl>

<dl class="py method">
<dt id="proveit.Lambda.extract_arguments">
<code class="sig-name descname">extract_arguments</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">mapped_expr</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/proveit/_core_/expression/lambda_expr/lambda_expr.html#Lambda.extract_arguments"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#proveit.Lambda.extract_arguments" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a mapped expression, return the arguments that will transform
this Lambda expression into the mapped expression.  For example,
if the Lambda expression is (x, y) -&gt; x + y and the mapped expression
is 1 + 2, this will return (1, 2).</p>
</dd></dl>

<dl class="py method">
<dt id="proveit.Lambda.global_repl">
<em class="property">static </em><code class="sig-name descname">global_repl</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">master_expr</span></em>, <em class="sig-param"><span class="n">sub_expr</span></em>, <em class="sig-param"><span class="n">assumptions</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/proveit/_core_/expression/lambda_expr/lambda_expr.html#Lambda.global_repl"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#proveit.Lambda.global_repl" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Lambda map for replacing the given sub-Expression
everywhere that it occurs in the master Expression.</p>
<p>When replacing an ExprTuple of operands, we will return a
lambda expression with a range of parameters for replacing the
operands individually.
For example,</p>
<blockquote>
<div><p>master_expr : a + b + c
sub_expr : (a, b, c)
will return something equal to</p>
<blockquote>
<div><p>(a_1, …, a_3) -&gt; a_1 + … + a_3</p>
</div></blockquote>
</div></blockquote>
<p>‘assumptions’ may be required for computing the number of
operands (which may contain ranges themselves) in this latter
process.</p>
</dd></dl>

<dl class="py method">
<dt id="proveit.Lambda.latex">
<code class="sig-name descname">latex</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">\*\*kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/proveit/_core_/expression/lambda_expr/lambda_expr.html#Lambda.latex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#proveit.Lambda.latex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a latex-formatted representation of the Expression.  The kwargs can contain formatting
directives (such as ‘fence’ used to indicate when a sub-expression should be wrapped in
parentheses if there can be ambiguity in the order of operations).</p>
</dd></dl>

<dl class="py method">
<dt id="proveit.Lambda.relabeled">
<code class="sig-name descname">relabeled</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">relabel_map</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/proveit/_core_/expression/lambda_expr/lambda_expr.html#Lambda.relabeled"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#proveit.Lambda.relabeled" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a variant of this Lambda expression with one or more
of its parameter labels changed.  The resulting expression
should be “equal” to the original (having the same meaning) but
essentially has a different “style” (formats differently) and
uses different labels for substitution purposes.</p>
</dd></dl>

<dl class="py method">
<dt id="proveit.Lambda.remake_arguments">
<code class="sig-name descname">remake_arguments</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/proveit/_core_/expression/lambda_expr/lambda_expr.html#Lambda.remake_arguments"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#proveit.Lambda.remake_arguments" title="Permalink to this definition">¶</a></dt>
<dd><p>Yield the argument values or (name, value) pairs
that could be used to recreate the Lambda expression.</p>
</dd></dl>

<dl class="py method">
<dt id="proveit.Lambda.string">
<code class="sig-name descname">string</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">\*\*kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/proveit/_core_/expression/lambda_expr/lambda_expr.html#Lambda.string"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#proveit.Lambda.string" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a string representation of the Expression.  The kwargs can contain formatting
directives (such as ‘fence’ used to indicate when a sub-expression should be wrapped in
parentheses if there can be ambiguity in the order of operations).</p>
</dd></dl>

</dd></dl>

</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">Prove-It</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="proveit.as_expression.html">as_expression</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.as_expressions.html">as_expressions</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.attempt_to_simplify.html">attempt_to_simplify</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.bundle.html">bundle</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.composite_expression.html">composite_expression</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.expression_depth.html">expression_depth</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.extract_var_tuple_indices.html">extract_var_tuple_indices</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.free_vars.html">free_vars</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.maybe_fenced.html">maybe_fenced</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.maybe_fenced_latex.html">maybe_fenced_latex</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.maybe_fenced_string.html">maybe_fenced_string</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.possibly_free_var_ranges.html">possibly_free_var_ranges</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.reset.html">reset</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.safe_default_or_dummy_var.html">safe_default_or_dummy_var</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.safe_dummy_var.html">safe_dummy_var</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.safe_dummy_vars.html">safe_dummy_vars</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.single_or_composite_expression.html">single_or_composite_expression</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.total_ordering.html">total_ordering</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.traverse_inner_expressions.html">traverse_inner_expressions</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.unbundle.html">unbundle</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.used_vars.html">used_vars</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.var_range.html">var_range</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="proveit.ArgumentExtractionError.html">ArgumentExtractionError</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.Assumption.html">Assumption</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.Axiom.html">Axiom</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.Composite.html">Composite</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.Conditional.html">Conditional</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.ConditionalSet.html">ConditionalSet</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.Deduction.html">Deduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.DisallowedParameterRelabeling.html">DisallowedParameterRelabeling</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.DuplicateLiteralError.html">DuplicateLiteralError</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.ExprArray.html">ExprArray</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.ExprRange.html">ExprRange</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.ExprTuple.html">ExprTuple</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.ExprTupleError.html">ExprTupleError</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.Expression.html">Expression</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.Function.html">Function</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.Generalization.html">Generalization</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.GeneralizationFailure.html">GeneralizationFailure</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.ImproperReplacement.html">ImproperReplacement</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.IndexedVar.html">IndexedVar</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.InnerExpr.html">InnerExpr</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.Instantiation.html">Instantiation</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.InstantiationFailure.html">InstantiationFailure</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.InvalidAssumptions.html">InvalidAssumptions</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.Judgment.html">Judgment</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.Label.html">Label</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Lambda</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.LambdaApplicationError.html">LambdaApplicationError</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.Literal.html">Literal</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.MakeNotImplemented.html">MakeNotImplemented</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.ModusPonens.html">ModusPonens</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.ModusPonensFailure.html">ModusPonensFailure</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.NamedExprs.html">NamedExprs</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.Operation.html">Operation</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.OperationError.html">OperationError</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.OperationOverInstances.html">OperationOverInstances</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.ParameterCollisionError.html">ParameterCollisionError</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.Proof.html">Proof</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.ProofFailure.html">ProofFailure</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.RangeInstanceError.html">RangeInstanceError</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.StyleOptions.html">StyleOptions</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.Theorem.html">Theorem</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.Theory.html">Theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.TheoryException.html">TheoryException</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.TheoryPackage.html">TheoryPackage</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.TransRelUpdater.html">TransRelUpdater</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.TransitiveRelation.html">TransitiveRelation</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.TransitivityException.html">TransitivityException</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.UnusableProof.html">UnusableProof</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.Variable.html">Variable</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="proveit.core_expr_types.Len.html">Len</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.compose.html">compose</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.conclude_via_implication.html">conclude_via_implication</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.default_simplification.html">default_simplification</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.evaluate_truth.html">evaluate_truth</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.in_bool.html">in_bool</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.is_irreducible_value.html">is_irreducible_value</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.not_proper_superset.html">not_proper_superset</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.not_superset_eq.html">not_superset_eq</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.proper_superset.html">proper_superset</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.reduce_operands.html">reduce_operands</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.superset_eq.html">superset_eq</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.And.html">And</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.BooleanSet.html">BooleanSet</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.Card.html">Card</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.Difference.html">Difference</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.Disjoint.html">Disjoint</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.Distinct.html">Distinct</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.Equals.html">Equals</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.EvaluationError.html">EvaluationError</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.Exists.html">Exists</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.FalseLiteral.html">FalseLiteral</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.Forall.html">Forall</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.Iff.html">Iff</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.Implies.html">Implies</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.InSet.html">InSet</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.Intersect.html">Intersect</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.IntersectAll.html">IntersectAll</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.IrreducibleValue.html">IrreducibleValue</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.Membership.html">Membership</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.Nonmembership.html">Nonmembership</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.Not.html">Not</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.NotEquals.html">NotEquals</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.NotExists.html">NotExists</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.NotInSet.html">NotInSet</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.NotProperSubset.html">NotProperSubset</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.NotSubsetEq.html">NotSubsetEq</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.Or.html">Or</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.PowerSet.html">PowerSet</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.ProperSubset.html">ProperSubset</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.Set.html">Set</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.SetEquiv.html">SetEquiv</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.SetNotEquiv.html">SetNotEquiv</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.SetOfAll.html">SetOfAll</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.SimplificationError.html">SimplificationError</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.StrictSubset.html">StrictSubset</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.SubsetEq.html">SubsetEq</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.SubsetProper.html">SubsetProper</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.TrueLiteral.html">TrueLiteral</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.Union.html">Union</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.logic.UnionAll.html">UnionAll</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="proveit.numbers.const_shift_composition.html">const_shift_composition</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.numbers.const_shift_decomposition.html">const_shift_decomposition</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.numbers.dist_add.html">dist_add</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.numbers.dist_subtract.html">dist_subtract</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.numbers.frac.html">frac</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.numbers.greater.html">greater</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.numbers.greater_eq.html">greater_eq</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.numbers.is_literal_int.html">is_literal_int</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.numbers.num.html">num</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.numbers.number_ordering.html">number_ordering</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.numbers.sqrt.html">sqrt</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.numbers.subtract.html">subtract</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="proveit.numbers.Abs.html">Abs</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.numbers.Add.html">Add</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.numbers.Ceil.html">Ceil</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.numbers.DecimalSequence.html">DecimalSequence</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.numbers.Div.html">Div</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.numbers.Divides.html">Divides</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.numbers.DividesProper.html">DividesProper</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.numbers.Exp.html">Exp</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.numbers.Floor.html">Floor</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.numbers.GCD.html">GCD</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.numbers.Integrate.html">Integrate</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.numbers.Interval.html">Interval</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.numbers.IntervalCC.html">IntervalCC</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.numbers.IntervalCO.html">IntervalCO</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.numbers.IntervalOC.html">IntervalOC</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.numbers.IntervalOO.html">IntervalOO</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.numbers.Less.html">Less</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.numbers.LessEq.html">LessEq</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.numbers.Max.html">Max</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.numbers.Min.html">Min</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.numbers.Mod.html">Mod</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.numbers.ModAbs.html">ModAbs</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.numbers.Mult.html">Mult</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.numbers.Neg.html">Neg</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.numbers.Numeral.html">Numeral</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.numbers.Prod.html">Prod</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.numbers.RealInterval.html">RealInterval</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.numbers.Round.html">Round</a></li>
<li class="toctree-l1"><a class="reference internal" href="proveit.numbers.Sum.html">Sum</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="proveit.Label.html" title="previous chapter">Label</a></li>
      <li>Next: <a href="proveit.LambdaApplicationError.html" title="next chapter">LambdaApplicationError</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, Wayne Witzel.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.3.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/api/proveit.Lambda.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>