
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>proveit._core_.judgment &#8212; Prove-It 0.3 documentation</title>
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for proveit._core_.judgment</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">A Judgment represents an expression that has been proven to be a true</span>
<span class="sd">statement.  A Judgment wraps an Expression (acting like the Expression</span>
<span class="sd">in many ways via overloading __getattr__) but also has a list of assumptions</span>
<span class="sd">and its proof (as a Proof object, which may be updated if a newer proof,</span>
<span class="sd">with possibly fewer assumptions, suffices).</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">proveit._core_.expression</span> <span class="k">import</span> <span class="n">Expression</span>
<span class="kn">from</span> <span class="nn">proveit._core_._unique_data</span> <span class="k">import</span> <span class="n">meaning_data</span><span class="p">,</span> <span class="n">style_data</span>
<span class="kn">from</span> <span class="nn">.defaults</span> <span class="k">import</span> <span class="n">defaults</span><span class="p">,</span> <span class="n">USE_DEFAULTS</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="k">import</span> <span class="n">copy</span>


<span class="k">class</span> <span class="nc">_ExprProofs</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Stores a set of proofs for a particular expression under any set</span>
<span class="sd">    of assumptions.  We maintain such sets so that we can update</span>
<span class="sd">    Judgment proofs appropriately when a particular proof has been</span>
<span class="sd">    disabled.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">all_expr_proofs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>  <span class="c1"># map expressions to expression proofs</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span> <span class="o">=</span> <span class="n">expr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_proofs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">_ExprProofs</span><span class="o">.</span><span class="n">all_expr_proofs</span><span class="p">[</span><span class="n">expr</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newproof</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Insert a new proof for the expression, maintaining sorted order</span>
<span class="sd">        in the proof size (number of steps).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">.proof</span> <span class="k">import</span> <span class="n">Proof</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">newproof</span><span class="p">,</span> <span class="n">Proof</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">newproof</span><span class="o">.</span><span class="n">proven_truth</span><span class="o">.</span><span class="n">expr</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_proofs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">newproof</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">discard</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">oldproof</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.proof</span> <span class="k">import</span> <span class="n">Proof</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">oldproof</span><span class="p">,</span> <span class="n">Proof</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">oldproof</span><span class="o">.</span><span class="n">proven_truth</span><span class="o">.</span><span class="n">expr</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">oldproof</span><span class="o">.</span><span class="n">is_usable</span><span class="p">(),</span> <span class="p">(</span>
                <span class="s2">&quot;Should only remove unusable proofs&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_proofs</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">oldproof</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">best_proof</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">judgment</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return the best proof applicable to the judgment that is usable</span>
<span class="sd">        (or None if there aren&#39;t any that are usable).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">judgment</span><span class="p">,</span> <span class="n">Judgment</span><span class="p">)</span>
        <span class="n">best_unusable_proof</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">fewest_steps</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">proof</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_proofs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">proof</span><span class="o">.</span><span class="n">proven_truth</span><span class="o">.</span><span class="n">assumptions_set</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span>
                    <span class="n">judgment</span><span class="o">.</span><span class="n">assumptions_set</span><span class="p">):</span>
                <span class="k">assert</span> <span class="n">proof</span><span class="o">.</span><span class="n">is_usable</span><span class="p">(),</span> <span class="p">(</span>
                        <span class="s1">&#39;unusable proofs should have been removed&#39;</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">proof</span><span class="o">.</span><span class="n">num_steps</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">fewest_steps</span><span class="p">:</span>
                    <span class="n">fewest_steps</span> <span class="o">=</span> <span class="n">proof</span><span class="o">.</span><span class="n">num_steps</span><span class="p">()</span>
                    <span class="n">best_unusable_proof</span> <span class="o">=</span> <span class="n">proof</span>
        <span class="c1"># the proof with the fewest steps that is applicable</span>
        <span class="k">return</span> <span class="n">best_unusable_proof</span>  


<div class="viewcode-block" id="Judgment"><a class="viewcode-back" href="../../../api/proveit.Judgment.html#proveit.Judgment">[docs]</a><span class="k">class</span> <span class="nc">Judgment</span><span class="p">:</span>
    <span class="c1"># lookup_dict maps each Expression to a set of Judgments for</span>
    <span class="c1"># proving the Expression under various assumptions.</span>
    <span class="n">lookup_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="c1"># (Judgment, default assumptions) pairs for which </span>
    <span class="c1"># derive_side_effects has been called.  We track this to make sure </span>
    <span class="c1"># we didn&#39;t miss anything while automation was disabled and then </span>
    <span class="c1"># re-enabled.</span>
    <span class="n">sideeffect_processed</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="c1"># Call the begin_proof method to begin a proof of a Theorem.</span>
    <span class="n">theorem_being_proven</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Theorem being proven.</span>
    <span class="c1"># Has the theorem_being_proven been proven yet in this session?</span>
    <span class="n">has_been_proven</span> <span class="o">=</span> <span class="kc">None</span>  
    <span class="c1"># Goes from None to False (after beginning a proof and disabling </span>
    <span class="c1"># Theorems that cannot be used) to True (when there is a legitimate</span>
    <span class="c1"># proof).</span>

    <span class="c1"># Set of theorems/packages that are presumed to be True for the</span>
    <span class="c1"># purposes of the proof being proven and exclusions thereof:</span>
    <span class="n">presumed_theorems_and_theories</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">presuming_theorem_and_theory_exclusions</span> <span class="o">=</span> <span class="kc">None</span>

     <span class="c1"># set if theorems and theories excluded from presumptions</span>
    <span class="n">presuming_exclusions</span> <span class="o">=</span> <span class="kc">None</span> 
    <span class="n">qed_in_progress</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># set to true when &quot;%qed&quot; is in progress</span>

    <span class="c1"># Judgments for which derive_side_effects is in progress, tracked to </span>
    <span class="c1"># prevent infinite recursion when deducing side effects after </span>
    <span class="c1"># something is proven.</span>
    <span class="n">in_progress_to_derive_sideeffects</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_clear_</span><span class="p">():</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Clear all references to Prove-It information in</span>
<span class="sd">        the Judgment jurisdiction.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">Judgment</span><span class="o">.</span><span class="n">lookup_dict</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">Judgment</span><span class="o">.</span><span class="n">sideeffect_processed</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">Judgment</span><span class="o">.</span><span class="n">theorem_being_proven</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">Judgment</span><span class="o">.</span><span class="n">has_been_proven</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">Judgment</span><span class="o">.</span><span class="n">presuming_theorems</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">Judgment</span><span class="o">.</span><span class="n">presuming_prefixes</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">Judgment</span><span class="o">.</span><span class="n">qed_in_progress</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">_ExprProofs</span><span class="o">.</span><span class="n">all_expr_proofs</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">Judgment</span><span class="o">.</span><span class="n">in_progress_to_derive_sideeffects</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span>
                <span class="s2">&quot;Unexpected remnant &#39;in_progress_to_derive_sideeffects&#39; &quot;</span>
                <span class="s2">&quot;items (should have been temporary)&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">assumptions</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Create a Judgment with the given Expression, set of assumptions.</span>
<span class="sd">        These should not be created manually but rather through the </span>
<span class="sd">        creation of Proofs which should be done indirectly via </span>
<span class="sd">        Expression/Judgment derivation-step methods.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># do some type checking</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">Expression</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;The expression (expr) of a Judgment should be an Expression&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">assumption</span> <span class="ow">in</span> <span class="n">assumptions</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">assumption</span><span class="p">,</span> <span class="n">Expression</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Each assumption should be an Expression&#39;</span><span class="p">)</span>

        <span class="c1"># Note: these contained expressions are subject to style changes</span>
        <span class="c1"># on a Judgment instance basis.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="o">=</span> <span class="n">expression</span>
        <span class="c1"># Store the assumptions as an ordered list (with the desired </span>
        <span class="c1"># order for display) and an unordered set (for convenience when </span>
        <span class="c1"># checking whether one set subsumes another).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assumptions</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">assumptions</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assumptions_set</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">assumptions</span><span class="p">)</span>

        <span class="c1"># The meaning data is shared among Judgments with the same</span>
        <span class="c1"># structure disregarding style</span>
        <span class="k">def</span> <span class="nf">meaning_id_fn</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span> <span class="k">return</span> <span class="nb">hex</span><span class="p">(</span>
            <span class="n">expr</span><span class="o">.</span><span class="n">_establish_and_get_meaning_id</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_meaning_data</span> <span class="o">=</span> <span class="n">meaning_data</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_generate_unique_rep</span><span class="p">(</span><span class="n">meaning_id_fn</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_meaning_data</span><span class="p">,</span> <span class="s1">&#39;_expr_proofs&#39;</span><span class="p">):</span>
            <span class="c1"># create or assign the _ExprProofs object for storing all </span>
            <span class="c1"># proofs for this Judgment&#39;s expr (under any set of </span>
            <span class="c1"># assumptions).</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="ow">in</span> <span class="n">_ExprProofs</span><span class="o">.</span><span class="n">all_expr_proofs</span><span class="p">:</span>
                <span class="n">expr_proofs</span> <span class="o">=</span> <span class="n">_ExprProofs</span><span class="o">.</span><span class="n">all_expr_proofs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">expr_proofs</span> <span class="o">=</span> <span class="n">_ExprProofs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_meaning_data</span><span class="o">.</span><span class="n">_expr_proofs</span> <span class="o">=</span> <span class="n">expr_proofs</span>
            <span class="c1"># Initially, _proof is None but will be assigned and updated</span>
            <span class="c1"># via _addProof()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_meaning_data</span><span class="o">.</span><span class="n">_proof</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># The style data is shared among Judgments with the same </span>
        <span class="c1"># structure and style.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_style_data</span> <span class="o">=</span> <span class="n">style_data</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_generate_unique_rep</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">expr</span><span class="p">:</span> <span class="nb">hex</span><span class="p">(</span>
                    <span class="n">expr</span><span class="o">.</span><span class="n">_style_id</span><span class="p">)))</span>

        <span class="c1"># reference this unchanging data of the unique &#39;meaning&#39; data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_meaning_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meaning_data</span><span class="o">.</span><span class="n">_unique_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_expr_proofs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meaning_data</span><span class="o">.</span><span class="n">_expr_proofs</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_style_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_style_data</span><span class="o">.</span><span class="n">_unique_id</span>

        <span class="c1"># The _proof can change so it must be accessed via indirection </span>
        <span class="c1"># into self._meaning_data (see proof() method).</span>

    <span class="k">def</span> <span class="nf">_generate_unique_rep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">object_rep_fn</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Generate a unique representation string using the given function</span>
<span class="sd">        to obtain representations of other referenced Prove-It objects.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">object_rep_fn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;;[&#39;</span> <span class="o">+</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="n">object_rep_fn</span><span class="p">(</span><span class="n">assumption</span><span class="p">)</span> <span class="k">for</span> <span class="n">assumption</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">assumptions</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;]&#39;</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_extractReferencedObjIds</span><span class="p">(</span><span class="n">unique_rep</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Given a unique representation string, returns the list of </span>
<span class="sd">        representations of Prove-It objects that are referenced.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># Everything between the punctuation, &#39;;&#39;, &#39;[&#39;, &#39;]&#39;, &#39;,&#39;, is a</span>
        <span class="c1"># represented object.</span>
        <span class="n">obj_ids</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;;|\[|,|\]&quot;</span><span class="p">,</span> <span class="n">unique_rep</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">obj_id</span> <span class="k">for</span> <span class="n">obj_id</span> <span class="ow">in</span> <span class="n">obj_ids</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">obj_id</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>

<div class="viewcode-block" id="Judgment.derive_side_effects"><a class="viewcode-back" href="../../../api/proveit.Judgment.html#proveit.Judgment.derive_side_effects">[docs]</a>    <span class="k">def</span> <span class="nf">derive_side_effects</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assumptions</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Derive any side-effects that are obvious consequences arising </span>
<span class="sd">        from this truth.  Called after the corresponding Proof is </span>
<span class="sd">        complete.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">.proof</span> <span class="k">import</span> <span class="n">ProofFailure</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">defaults</span><span class="o">.</span><span class="n">automation</span><span class="p">:</span>
            <span class="k">return</span>  <span class="c1"># automation disabled</span>
        <span class="c1"># Sort the assumptions according to hash key so that sets of</span>
        <span class="c1"># assumptions are unique for determining which side-effects have</span>
        <span class="c1"># been processedalready.</span>
        <span class="n">sorted_assumptions</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="nb">sorted</span><span class="p">(</span>
                <span class="n">assumptions</span><span class="p">,</span>
                <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">expr</span><span class="p">:</span> <span class="nb">hash</span><span class="p">(</span><span class="n">expr</span><span class="p">)))</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="n">sorted_assumptions</span><span class="p">)</span> <span class="ow">in</span> <span class="n">Judgment</span><span class="o">.</span><span class="n">sideeffect_processed</span><span class="p">:</span>
            <span class="k">return</span>  <span class="c1"># has already been processed</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Judgment</span><span class="o">.</span><span class="n">in_progress_to_derive_sideeffects</span><span class="p">:</span>
            <span class="c1"># avoid infinite recursion by using</span>
            <span class="c1"># in_progress_to_deduce_sideeffects</span>
            <span class="n">Judgment</span><span class="o">.</span><span class="n">in_progress_to_derive_sideeffects</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">side_effect</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">side_effects</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                    <span class="c1">#print(self, &quot;side-effect&quot;, side_effect)</span>
                    <span class="c1"># Attempt each side-effect derivation, specific to </span>
                    <span class="c1"># thetype of Expression.</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="c1"># use the default assumptions which are </span>
                        <span class="c1"># temporarily set to the assumptions utilized</span>
                        <span class="c1"># in the last derivation step.</span>
                        <span class="n">side_effect</span><span class="p">(</span><span class="n">assumptions</span><span class="o">=</span><span class="n">assumptions</span><span class="p">)</span>
                    <span class="k">except</span> <span class="n">ProofFailure</span><span class="p">:</span>
                        <span class="k">pass</span>
                    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                            <span class="s2">&quot;Side effect failure for </span><span class="si">%s</span><span class="s2">, while running </span><span class="si">%s</span><span class="s2">: &quot;</span> <span class="o">%</span>
                            <span class="p">(</span><span class="nb">str</span><span class="p">(</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">),</span>
                                <span class="nb">str</span><span class="p">(</span><span class="n">side_effect</span><span class="p">))</span> <span class="o">+</span>
                            <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="n">Judgment</span><span class="o">.</span><span class="n">in_progress_to_derive_sideeffects</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">Judgment</span><span class="o">.</span><span class="n">sideeffect_processed</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="n">sorted_assumptions</span><span class="p">))</span></div>

<div class="viewcode-block" id="Judgment.order_of_appearance"><a class="viewcode-back" href="../../../api/proveit.Judgment.html#proveit.Judgment.order_of_appearance">[docs]</a>    <span class="k">def</span> <span class="nf">order_of_appearance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sub_expressions</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Yields the given sub-Expressions in the order in which they</span>
<span class="sd">        appear in this Judgment.  There may be repeats.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">assumption</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">assumptions</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">assumption</span><span class="o">.</span><span class="n">order_of_appearance</span><span class="p">(</span><span class="n">sub_expressions</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">expr</span>
        <span class="k">for</span> <span class="n">expr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">order_of_appearance</span><span class="p">(</span><span class="n">sub_expressions</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">expr</span></div>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Judgment</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meaning_id</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_meaning_id</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># other must be an Expression to be equal to self</span>
            <span class="k">return</span> <span class="kc">False</span>  

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meaning_id</span>

<div class="viewcode-block" id="Judgment.begin_proof"><a class="viewcode-back" href="../../../api/proveit.Judgment.html#proveit.Judgment.begin_proof">[docs]</a>    <span class="k">def</span> <span class="nf">begin_proof</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theorem</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Begin a proof for a theorem.  Only use other theorems that are </span>
<span class="sd">        in the presuming list of theorems/packages or theorems that are </span>
<span class="sd">        required, directly or indirectly, in proofs of theorems that are</span>
<span class="sd">        explicitly listed (these are implicitly presumed).  If there </span>
<span class="sd">        exists any presumed theorem that has a direct or indirect </span>
<span class="sd">        dependence upon this theorem then a CircularLogic exception is</span>
<span class="sd">        raised.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">.proof</span> <span class="k">import</span> <span class="n">Theorem</span>
        <span class="k">if</span> <span class="n">Judgment</span><span class="o">.</span><span class="n">theorem_being_proven</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ProofInitiationFailure</span><span class="p">(</span>
                <span class="s2">&quot;May only begin_proof once per Python/IPython session. &quot;</span>
                <span class="s2">&quot;Restart the notebook to restart the proof.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">theorem</span><span class="p">,</span> <span class="n">Theorem</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Only begin a proof for a Theorem&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">theorem</span><span class="o">.</span><span class="n">proven_truth</span> <span class="o">!=</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Inconsistent theorem for the Judgment in begin_proof call&#39;</span><span class="p">)</span>

        <span class="c1"># The full list of presumed theorems includes all previous </span>
        <span class="c1"># theoremsof the theory and all indirectly presumed theorems </span>
        <span class="c1"># via transitivity (a presumption of a presumption is a</span>
        <span class="c1"># presumption).</span>
        <span class="n">presumptions</span><span class="p">,</span> <span class="n">exclusions</span> <span class="o">=</span> <span class="n">theorem</span><span class="o">.</span><span class="n">get_presumptions_and_exclusions</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">in</span> <span class="n">presumptions</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">.proof</span> <span class="k">import</span> <span class="n">CircularLogic</span>
            <span class="c1"># extra sanity check (should be caught within</span>
            <span class="c1"># get_all_presumed_theorem_names)</span>
            <span class="k">raise</span> <span class="n">CircularLogic</span><span class="p">(</span><span class="n">theorem</span><span class="p">,</span> <span class="n">theorem</span><span class="p">)</span>

        <span class="n">Judgment</span><span class="o">.</span><span class="n">theorem_being_proven</span> <span class="o">=</span> <span class="n">theorem</span>
        <span class="n">Judgment</span><span class="o">.</span><span class="n">presumed_theorems_and_theories</span> <span class="o">=</span> <span class="n">presumptions</span>
        <span class="n">Judgment</span><span class="o">.</span><span class="n">presuming_theorem_and_theory_exclusions</span> <span class="o">=</span> <span class="n">exclusions</span>
        <span class="n">Theorem</span><span class="o">.</span><span class="n">update_usability</span><span class="p">()</span>

        <span class="c1"># change Judgment.has_been_proven</span>
        <span class="c1"># from None to False -- we can now test to see if</span>
        <span class="c1"># we have a proof for Judgment.theorem_being_proven</span>
        <span class="n">Judgment</span><span class="o">.</span><span class="n">has_been_proven</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_checkIfReadyForQED</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proof</span><span class="p">()):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span>  <span class="c1"># already proven</span>
        <span class="c1"># can&#39;t use itself to prove itself</span>
        <span class="n">theorem</span><span class="o">.</span><span class="n">_meaning_data</span><span class="o">.</span><span class="n">_unusable_proof</span> <span class="o">=</span> <span class="n">theorem</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span></div>

    <span class="k">def</span> <span class="nf">_qed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Complete a proof that began via `begin_proof`, entering it into</span>
<span class="sd">        the certification database.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">Judgment</span><span class="o">.</span><span class="n">theorem_being_proven</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;No theorem being proven; cannot call qed method&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="o">!=</span> <span class="n">Judgment</span><span class="o">.</span><span class="n">theorem_being_proven</span><span class="o">.</span><span class="n">proven_truth</span><span class="o">.</span><span class="n">expr</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;qed does not match the theorem being proven&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">assumptions</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s1">&#39;qed proof should not have any remaining assumptions&#39;</span><span class="p">)</span>
        <span class="n">Judgment</span><span class="o">.</span><span class="n">qed_in_progress</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">proof</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">prove</span><span class="p">(</span><span class="n">assumptions</span><span class="o">=</span><span class="p">[])</span><span class="o">.</span><span class="n">proof</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">proof</span><span class="o">.</span><span class="n">is_usable</span><span class="p">():</span>
                <span class="n">proof</span><span class="o">.</span><span class="n">proven_truth</span><span class="o">.</span><span class="n">raise_unusable_proof</span><span class="p">()</span>
            <span class="n">Judgment</span><span class="o">.</span><span class="n">theorem_being_proven</span><span class="o">.</span><span class="n">_recordProof</span><span class="p">(</span><span class="n">proof</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="n">Judgment</span><span class="o">.</span><span class="n">qed_in_progress</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">proof</span>

<div class="viewcode-block" id="Judgment.proof"><a class="viewcode-back" href="../../../api/proveit.Judgment.html#proveit.Judgment.proof">[docs]</a>    <span class="k">def</span> <span class="nf">proof</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns the most up-to-date proof of this Judgment.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meaning_data</span><span class="o">.</span><span class="n">_proof</span></div>

<div class="viewcode-block" id="Judgment.is_usable"><a class="viewcode-back" href="../../../api/proveit.Judgment.html#proveit.Judgment.is_usable">[docs]</a>    <span class="k">def</span> <span class="nf">is_usable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns True iff this Judgment has a &quot;usable&quot; proof.  Proofs</span>
<span class="sd">        may be unusable when proving a theorem that is restricted with</span>
<span class="sd">        respect to which theorems may be used (to avoid circular logic).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">proof</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proof</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">proof</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">proof</span><span class="o">.</span><span class="n">is_usable</span><span class="p">()</span></div>

<div class="viewcode-block" id="Judgment.is_sufficient"><a class="viewcode-back" href="../../../api/proveit.Judgment.html#proveit.Judgment.is_sufficient">[docs]</a>    <span class="k">def</span> <span class="nf">is_sufficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assumptions</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return True iff the given assumptions satisfy the Judgment;</span>
<span class="sd">        the Judgment is usable and requires a subset of the given </span>
<span class="sd">        assumptions.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_usable</span><span class="p">()</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">assumptions_set</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">assumptions</span><span class="p">)</span></div>

<div class="viewcode-block" id="Judgment.as_theorem_or_axiom"><a class="viewcode-back" href="../../../api/proveit.Judgment.html#proveit.Judgment.as_theorem_or_axiom">[docs]</a>    <span class="k">def</span> <span class="nf">as_theorem_or_axiom</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Assuming this Judgment represents a Theorem or Axiom, return</span>
<span class="sd">        the Theorem or Axiom object.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">.proof</span> <span class="k">import</span> <span class="n">Theorem</span><span class="p">,</span> <span class="n">Axiom</span>
        <span class="c1"># Get the theorem associated with the Judgment (or raise an exception</span>
        <span class="c1"># if there is none)</span>
        <span class="k">if</span> <span class="n">Judgment</span><span class="o">.</span><span class="n">theorem_being_proven</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="o">==</span> <span class="n">Judgment</span><span class="o">.</span><span class="n">theorem_being_proven</span><span class="o">.</span><span class="n">proven_truth</span><span class="o">.</span><span class="n">expr</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Judgment</span><span class="o">.</span><span class="n">theorem_being_proven</span>
        <span class="n">proof</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proof</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">proof</span><span class="p">,</span> <span class="n">Theorem</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">proof</span><span class="p">,</span> <span class="n">Axiom</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">proof</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Judgment does not represent a theorem or axiom.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Judgment.print_requirements"><a class="viewcode-back" href="../../../api/proveit.Judgment.html#proveit.Judgment.print_requirements">[docs]</a>    <span class="k">def</span> <span class="nf">print_requirements</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Provided that this Judgment is known to represent a proven</span>
<span class="sd">        theorem, print the set of axioms that are required directly or </span>
<span class="sd">        indirectly inits proof as well as any required theorems that are</span>
<span class="sd">        unproven (if it has not yet been proven completely).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.certify</span> <span class="k">import</span> <span class="n">is_fully_proven</span><span class="p">,</span> <span class="n">all_requirements</span>
        <span class="c1"># print the required axioms and unproven theorems</span>
        <span class="n">required_axioms</span><span class="p">,</span> <span class="n">required_theorems</span> <span class="o">=</span> <span class="n">all_requirements</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">axiom</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">required_axioms</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">axiom</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">required_theorems</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">is_fully_proven</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="s2">&quot;certification database is corrupt&quot;</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Theorem is fully proven!&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">required_theorems</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">is_fully_proven</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">),</span> <span class="s2">&quot;certification database is corrupt&quot;</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">_unproven theorems:&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">theorem</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">required_theorems</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">theorem</span><span class="p">)</span></div>

<div class="viewcode-block" id="Judgment.print_dependents"><a class="viewcode-back" href="../../../api/proveit.Judgment.html#proveit.Judgment.print_dependents">[docs]</a>    <span class="k">def</span> <span class="nf">print_dependents</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Provided that this Judgment is known to represent a theorem or </span>
<span class="sd">        axiom, print all theorems that are known to depend on it </span>
<span class="sd">        directly or indirectly.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.certify</span> <span class="k">import</span> <span class="n">all_dependents</span>
        <span class="n">dependents</span> <span class="o">=</span> <span class="n">all_dependents</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">theorem</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">dependents</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">theorem</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_discardProof</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proof</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Discard a disabled proof as an option in the _ExprProofs object.</span>
<span class="sd">        Don&#39;t change self._meaning_data._proof, now, however.  It will </span>
<span class="sd">        be updated in due time and may be replaced with a proof that </span>
<span class="sd">        hasn&#39;t been disabled.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_expr_proofs</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">proof</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_addProof</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newproof</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        After a Proof is finished being constructed, record the best</span>
<span class="sd">        proof for the Judgment which may be the new proof, &#39;proof&#39;,</span>
<span class="sd">        or a pre-existing one.  Update all Judgments</span>
<span class="sd">        with the same &#39;truth&#39; expression that should be updated.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># print &#39;record best&#39;, self.expr, &#39;under&#39;, self.assumptions</span>
        <span class="c1"># update Judgment.lookup_dict and use find all of the Judgments</span>
        <span class="c1"># with this expr to see if the proof should be updated with the</span>
        <span class="c1"># new proof.</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">newproof</span><span class="o">.</span><span class="n">is_usable</span><span class="p">():</span>
            <span class="c1"># Don&#39;t bother with a disabled proof unless it is the only</span>
            <span class="c1"># proof.  in that case, we record it so we can generate a </span>
            <span class="c1"># useful error message via raise_unusable_proof(..).</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meaning_data</span><span class="o">.</span><span class="n">_proof</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_meaning_data</span><span class="o">.</span><span class="n">_proof</span> <span class="o">=</span> <span class="n">newproof</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_expr_proofs</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">newproof</span><span class="p">)</span>

        <span class="c1"># Check to see if the new proof is applicable to any other </span>
        <span class="c1"># Judgment.  It can replace an old proof if it became unusable </span>
        <span class="c1"># or if the newer one uses fewer steps.</span>
        <span class="n">expr_judgments</span> <span class="o">=</span> <span class="n">Judgment</span><span class="o">.</span><span class="n">lookup_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span>
        <span class="n">expr_judgments</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">expr_judgment</span> <span class="ow">in</span> <span class="n">expr_judgments</span><span class="p">:</span>
            <span class="c1"># Is &#39;proof&#39; applicable to &#39;expr_judgment&#39;?</span>
            <span class="k">if</span> <span class="n">newproof</span><span class="o">.</span><span class="n">proven_truth</span><span class="o">.</span><span class="n">assumptions_set</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span>
                    <span class="n">expr_judgment</span><span class="o">.</span><span class="n">assumptions_set</span><span class="p">):</span>
                <span class="c1"># replace if there was no pre-existing usable proof or </span>
                <span class="c1"># the new proof has fewer steps</span>
                <span class="n">preexisting_proof</span> <span class="o">=</span> <span class="n">expr_judgment</span><span class="o">.</span><span class="n">proof</span><span class="p">()</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">preexisting_proof</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span>
                        <span class="ow">not</span> <span class="n">preexisting_proof</span><span class="o">.</span><span class="n">is_usable</span><span class="p">()</span> <span class="ow">or</span>
                        <span class="n">newproof</span><span class="o">.</span><span class="n">num_steps</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">preexisting_proof</span><span class="o">.</span><span class="n">num_steps</span><span class="p">()):</span>
                    <span class="n">expr_judgment</span><span class="o">.</span><span class="n">_updateProof</span><span class="p">(</span>
                        <span class="n">newproof</span><span class="p">)</span>  <span class="c1"># replace an old proof</span>

    <span class="k">def</span> <span class="nf">_reviseProof</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        After a proof and its dependents have been disabled, we will see</span>
<span class="sd">        if there is another proof that is usable (see Proof.disable()).</span>
<span class="sd">        Return True iff the proof actually changed to something usable.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_updateProof</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_expr_proofs</span><span class="o">.</span><span class="n">best_proof</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    def _recordBestProof(self, new_proof):</span>
<span class="sd">        &#39;&#39;&#39;</span>
<span class="sd">        After a Proof is finished being constructed, check to see if</span>
<span class="sd">        any proofs for this Judgment are obsolete; the new proof</span>
<span class="sd">        might make a previous one obsolete, or it may be born</span>
<span class="sd">        obsolete itself.  A proof is obsolete if there exists a Judgment</span>
<span class="sd">        with a subset of the assumptions required for that proof, or with</span>
<span class="sd">        the same set of assumptions but fewer steps.  A tie goes to the</span>
<span class="sd">        new proof, but note that the step number comparison will prevent</span>
<span class="sd">        anything cyclic (since a proof for a Judgment that requires that</span>
<span class="sd">        same Judgment as a dependent will necessarily include the</span>
<span class="sd">        number of steps of the original proof plus more).</span>
<span class="sd">        &#39;&#39;&#39;</span>
<span class="sd">        self._updateProof(self._expr_proofs.best_proof(self))</span>


<span class="sd">        from proof import Theorem</span>
<span class="sd">        if not self.expr in Judgment.lookup_dict:</span>
<span class="sd">            # the first Judgment for this Expression</span>
<span class="sd">            self._proof = new_proof</span>
<span class="sd">            Judgment.lookup_dict[self.expr] = [self]</span>
<span class="sd">            return</span>
<span class="sd">        if not new_proof.is_usable():</span>
<span class="sd">            # if it is not usable, we&#39;re done.</span>
<span class="sd">            if self._proof is None:</span>
<span class="sd">                # but first set _proof to the new_proof if there</span>
<span class="sd">                # is not another one.</span>
<span class="sd">                self._proof = new_proof</span>
<span class="sd">            return</span>
<span class="sd">        kept_truths = []</span>
<span class="sd">        born_obsolete = False</span>
<span class="sd">        for other in Judgment.lookup_dict[self.expr]:</span>
<span class="sd">            if self.assumptions_set == other.assumptions_set:</span>
<span class="sd">                if not other._proof.is_usable():</span>
<span class="sd">                    # use the new proof since the old one is unusable.</span>
<span class="sd">                    other._updateProof(new_proof)</span>
<span class="sd">                elif new_proof.num_steps &lt;= other._proof.num_steps:</span>
<span class="sd">                    if new_proof.required_proofs != other._proof.required_proofs:</span>
<span class="sd">                        # use the new (different) proof that does the job as well or better</span>
<span class="sd">                        if isinstance(new_proof, Theorem):</span>
<span class="sd">                            # newer proof is a theorem; record the existing proof as a possible proof for that theorem</span>
<span class="sd">                            new_proof._possibleProofs.append(other._proof)</span>
<span class="sd">                        other._updateProof(new_proof)</span>
<span class="sd">                else:</span>
<span class="sd">                    # the new proof was born obsolete, taking more steps than an existing one</span>
<span class="sd">                    if isinstance(other._proof, Theorem):</span>
<span class="sd">                        # the older proof is a theorem, record the new proof as a possible proof for that theorem</span>
<span class="sd">                        other._proof._possibleProofs.append(new_proof)</span>
<span class="sd">                    self._proof = other._proof # use an old proof that does the job better</span>
<span class="sd">                    kept_truths.append(other)</span>
<span class="sd">                    born_obsolete = True</span>
<span class="sd">            elif self.assumptions_set.issubset(other.assumptions_set):</span>
<span class="sd">                # use the new proof that does the job better</span>
<span class="sd">                other._updateProof(new_proof)</span>
<span class="sd">            elif self.assumptions_set.issuperset(other.assumptions_set) and other._proof.is_usable():</span>
<span class="sd">                # the new proof was born obsolete, requiring more assumptions than an existing one</span>
<span class="sd">                self._proof = other._proof # use an old proof that does the job better</span>
<span class="sd">                kept_truths.append(other)</span>
<span class="sd">                born_obsolete = True</span>
<span class="sd">            else:</span>
<span class="sd">                # &#39;other&#39; uses a different, non-redundant set of assumptions or</span>
<span class="sd">                # uses a subset of the assumptions but is unusable</span>
<span class="sd">                kept_truths.append(other)</span>
<span class="sd">        if not born_obsolete:</span>
<span class="sd">            if Judgment.theorem_being_proven is not None:</span>
<span class="sd">                if not Judgment.qed_in_progress and len(self.assumptions)==0 and self.expr == Judgment.theorem_being_proven.proven_truth.expr:</span>
<span class="sd">                    if not Judgment.has_been_proven:</span>
<span class="sd">                        Judgment.has_been_proven = True</span>
<span class="sd">                        print &#39;%s has been proven. &#39;%self.as_theorem_or_axiom().name, r&#39;Now simply execute &quot;%qed&quot;.&#39;</span>
<span class="sd">            self._proof = new_proof</span>
<span class="sd">            kept_truths.append(self)</span>
<span class="sd">        # Remove the obsolete Judgments from the lookup_dict -- SHOULD ACTUALLY KEEP OLD PROOFS IN CASE ONE IS DISABLED -- TODO</span>
<span class="sd">        Judgment.lookup_dict[self.expr] = kept_truths</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_updateProof</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_proof</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Update the proof of this Judgment.  Return True iff the proof actually changed to something usable.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">meaning_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meaning_data</span>

        <span class="k">if</span> <span class="n">new_proof</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># no usable proof.</span>
            <span class="c1"># no need to update dependencies because that would have </span>
            <span class="c1"># already been done when the proof was disabled.</span>
            <span class="k">if</span> <span class="n">meaning_data</span><span class="o">.</span><span class="n">_proof</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">assert</span> <span class="ow">not</span> <span class="n">meaning_data</span><span class="o">.</span><span class="n">_proof</span><span class="o">.</span><span class="n">is_usable</span><span class="p">(),</span> <span class="p">(</span>
                        <span class="s2">&quot;should not update to an unusable new proof &quot;</span>
                        <span class="s2">&quot;if the old one was usable&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>  <span class="c1"># did not change to something usable</span>
        <span class="k">assert</span> <span class="n">new_proof</span><span class="o">.</span><span class="n">is_usable</span><span class="p">(),</span> <span class="p">(</span>
                <span class="s2">&quot;Should not update with an unusable proof&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_checkIfReadyForQED</span><span class="p">(</span><span class="n">new_proof</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">meaning_data</span><span class="o">.</span><span class="n">_proof</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># no previous dependents to update</span>
            <span class="n">meaning_data</span><span class="o">.</span><span class="n">_proof</span> <span class="o">=</span> <span class="n">new_proof</span>
            <span class="k">return</span> <span class="kc">True</span>  <span class="c1"># new usable proof</span>
        <span class="k">elif</span> <span class="n">meaning_data</span><span class="o">.</span><span class="n">_proof</span> <span class="o">==</span> <span class="n">new_proof</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>  <span class="c1"># no change</span>

        <span class="c1"># swap out the old proof for the new proof in all dependencies</span>
        <span class="n">meaning_data</span><span class="o">.</span><span class="n">_proof</span><span class="o">.</span><span class="n">_updateDependencies</span><span class="p">(</span><span class="n">new_proof</span><span class="p">)</span>
        <span class="n">meaning_data</span><span class="o">.</span><span class="n">_proof</span> <span class="o">=</span> <span class="n">new_proof</span>  <span class="c1"># set to the new proof</span>

        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_checkIfReadyForQED</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proof</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">proof</span><span class="o">.</span><span class="n">is_usable</span><span class="p">()</span> <span class="ow">and</span> <span class="n">proof</span><span class="o">.</span><span class="n">proven_truth</span> <span class="o">==</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">Judgment</span><span class="o">.</span><span class="n">has_been_proven</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># check if we have a usable proof for the theorem being</span>
                <span class="c1"># proven</span>
                <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">Judgment</span><span class="o">.</span><span class="n">qed_in_progress</span> <span class="ow">and</span> 
                        <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">assumptions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> 
                        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="o">==</span> 
                         <span class="n">Judgment</span><span class="o">.</span><span class="n">theorem_being_proven</span><span class="o">.</span><span class="n">proven_truth</span><span class="o">.</span><span class="n">expr</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">Judgment</span><span class="o">.</span><span class="n">has_been_proven</span><span class="p">:</span>
                        <span class="n">Judgment</span><span class="o">.</span><span class="n">has_been_proven</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> has been proven. &#39;</span> <span class="o">%</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">as_theorem_or_axiom</span><span class="p">()</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                            <span class="sa">r</span><span class="s1">&#39;Now simply execute &quot;%qed&quot;.&#39;</span><span class="p">)</span>
                        <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Judgments should be read-only objects.  Attributes may be added, </span>
<span class="sd">        however; for example, the &#39;png&#39; attribute which will be added</span>
<span class="sd">        whenever it is generated).   Also, _proof is an exception which </span>
<span class="sd">        can be updated internally.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">attr</span> <span class="o">!=</span> <span class="s1">&#39;_proof&#39;</span> <span class="ow">and</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Attempting to alter read-only value&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        The Judgment aquires the attributes of its Expression, so it </span>
<span class="sd">        will act like the Expression except it has additional (or </span>
<span class="sd">        possibly overridden) attributes.  When accessing functions of </span>
<span class="sd">        the Expression, if that function has &#39;assumptions&#39; as a keyword</span>
<span class="sd">        argument, the assumptions of the Judgment are automatically</span>
<span class="sd">        included.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit</span> <span class="k">import</span> <span class="n">defaults</span><span class="p">,</span> <span class="n">USE_DEFAULTS</span>
        <span class="kn">import</span> <span class="nn">inspect</span>

        <span class="c1"># called only if the attribute does not exist in Judgment </span>
        <span class="c1"># directly</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;png&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="s2">&quot;Do not use the Expression version of the &#39;png&#39; &quot;</span>
                <span class="s2">&quot;attribute.&quot;</span><span class="p">)</span>
        <span class="n">attr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">name</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;with_&#39;</span><span class="p">:</span>
                <span class="c1"># &#39;with_...&#39; methods change the style.  We want to</span>
                <span class="c1"># change the style and the return the judgment.</span>
                <span class="k">def</span> <span class="nf">call_method_for_new_style</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                    <span class="n">new_style_expr</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">with_matching_styles</span><span class="p">(</span><span class="n">new_style_expr</span><span class="p">,</span> <span class="p">[])</span>
                <span class="k">return</span> <span class="n">call_method_for_new_style</span>
            <span class="n">argspec</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getfullargspec</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;assumptions&#39;</span> <span class="ow">in</span> <span class="n">argspec</span><span class="o">.</span><span class="n">args</span>
                    <span class="ow">or</span> <span class="s1">&#39;assumptions&#39;</span> <span class="ow">in</span> <span class="n">argspec</span><span class="o">.</span><span class="n">kwonlyargs</span><span class="p">):</span>
                <span class="c1"># The attribute is a callable function with</span>
                <span class="c1"># &#39;assumptions&#39; as an argument.</span>
                <span class="c1"># Automatically include the Judgment assumptions.</span>

                <span class="c1"># note, index zero is self.</span>
                <span class="k">if</span> <span class="s1">&#39;assumptions&#39;</span> <span class="ow">in</span> <span class="n">argspec</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                    <span class="n">assumptions_idx</span> <span class="o">=</span> <span class="n">argspec</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;assumptions&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">assumptions_idx</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># &#39;assumptions&#39; is kwonly</span>

                <span class="k">def</span> <span class="nf">call_method_with_judgment_assumptions</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">assumptions_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                            <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">assumptions_idx</span><span class="p">):</span>
                        <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
                        <span class="n">assumptions</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">assumptions_idx</span><span class="p">]</span>
                        <span class="n">assumptions</span> <span class="o">=</span> <span class="n">defaults</span><span class="o">.</span><span class="n">checked_assumptions</span><span class="p">(</span><span class="n">assumptions</span><span class="p">)</span>
                        <span class="n">assumptions</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">assumptions</span>
                        <span class="n">args</span><span class="p">[</span><span class="n">assumptions_idx</span><span class="p">]</span> <span class="o">=</span> \
                            <span class="n">defaults</span><span class="o">.</span><span class="n">checked_assumptions</span><span class="p">(</span><span class="n">assumptions</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">assumptions</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;assumptions&#39;</span><span class="p">,</span> <span class="n">USE_DEFAULTS</span><span class="p">)</span>
                        <span class="n">assumptions</span> <span class="o">=</span> <span class="n">defaults</span><span class="o">.</span><span class="n">checked_assumptions</span><span class="p">(</span><span class="n">assumptions</span><span class="p">)</span>
                        <span class="n">assumptions</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">assumptions</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">assumptions</span>
                        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;assumptions&#39;</span><span class="p">]</span> <span class="o">=</span> \
                            <span class="n">defaults</span><span class="o">.</span><span class="n">checked_assumptions</span><span class="p">(</span><span class="n">assumptions</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">attr</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">call_method_with_judgment_assumptions</span>

        <span class="k">return</span> <span class="n">attr</span>

    <span class="k">def</span> <span class="nf">__dir__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        The Judgment aquires the attributes of its Expression as well as </span>
<span class="sd">        its own attributes.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">dir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span> <span class="o">+</span>
                          <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">+</span> <span class="nb">dir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">)))</span>

<div class="viewcode-block" id="Judgment.with_matching_styles"><a class="viewcode-back" href="../../../api/proveit.Judgment.html#proveit.Judgment.with_matching_styles">[docs]</a>    <span class="k">def</span> <span class="nf">with_matching_styles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">assumptions</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return the Judgement expression with the styles matching</span>
<span class="sd">        those of the given expression and assumptions.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">new_style_expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">with_matching_style</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="c1"># storing the assumptions in a trivial dictionary will be useful</span>
        <span class="c1"># for popping them out.</span>
        <span class="n">assumptions_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">assumption</span><span class="p">:</span> <span class="n">assumption</span> <span class="k">for</span> <span class="n">assumption</span> <span class="ow">in</span> <span class="n">assumptions</span><span class="p">}</span>
        <span class="n">new_style_assumptions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">assumption</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">assumptions</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">assumption</span> <span class="ow">in</span> <span class="n">assumptions_dict</span><span class="p">:</span>
                <span class="n">new_style_assumptions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">assumption</span><span class="o">.</span><span class="n">with_matching_style</span><span class="p">(</span>
                                <span class="n">assumptions_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">assumption</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_style_assumptions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">assumption</span><span class="p">)</span>
        <span class="n">new_style_judgment</span> <span class="o">=</span> \
            <span class="n">Judgment</span><span class="p">(</span><span class="n">new_style_expr</span><span class="p">,</span> <span class="n">new_style_assumptions</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">new_style_expr</span><span class="o">.</span><span class="n">_style_id</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">_style_id</span><span class="p">)</span> <span class="ow">and</span>
                <span class="nb">all</span><span class="p">(</span><span class="n">new_style_assumption</span><span class="o">.</span><span class="n">_style_id</span> <span class="o">==</span> <span class="n">old_assumption</span><span class="o">.</span><span class="n">_style_id</span>
                    <span class="k">for</span> <span class="n">new_style_assumption</span><span class="p">,</span> <span class="n">old_assumption</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                            <span class="n">new_style_assumptions</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">assumptions</span><span class="p">))):</span>
            <span class="c1"># Nothing has changed.</span>
            <span class="k">return</span> <span class="bp">self</span>
            
        <span class="n">proof</span> <span class="o">=</span> <span class="n">new_style_judgment</span><span class="o">.</span><span class="n">proof</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">proof</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Update the style for the proof if there is one.</span>
            <span class="n">new_style_proof</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">proof</span><span class="p">)</span>
            <span class="n">new_style_proof</span><span class="o">.</span><span class="n">proven_truth</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_meaning_data</span><span class="o">.</span><span class="n">_expr_proofs</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
                    <span class="n">new_style_proof</span><span class="p">)</span>
            <span class="n">new_style_judgment</span><span class="o">.</span><span class="n">_meaning_data</span><span class="o">.</span><span class="n">_proof</span> <span class="o">=</span> \
                <span class="n">new_style_proof</span>
        <span class="k">return</span> <span class="n">new_style_judgment</span></div>

<div class="viewcode-block" id="Judgment.find_judgment"><a class="viewcode-back" href="../../../api/proveit.Judgment.html#proveit.Judgment.find_judgment">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">find_judgment</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">assumptions_set</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Try to find a Judgment for this expression that applies to</span>
<span class="sd">        the given set of assumptions (its assumptions are a subset</span>
<span class="sd">        of the given assumptions).  Return None if there is no match.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">expression</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Judgment</span><span class="o">.</span><span class="n">lookup_dict</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">truths</span> <span class="o">=</span> <span class="n">Judgment</span><span class="o">.</span><span class="n">lookup_dict</span><span class="p">[</span><span class="n">expression</span><span class="p">]</span>
        <span class="n">suitable_truths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">truth</span> <span class="ow">in</span> <span class="n">truths</span><span class="p">:</span>
            <span class="n">proof</span> <span class="o">=</span> <span class="n">truth</span><span class="o">.</span><span class="n">proof</span><span class="p">()</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">proof</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">proof</span><span class="o">.</span><span class="n">is_usable</span><span class="p">()</span> <span class="ow">and</span>
                    <span class="n">truth</span><span class="o">.</span><span class="n">assumptions_set</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">assumptions_set</span><span class="p">)):</span>
                <span class="n">suitable_truths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">truth</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">suitable_truths</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>  <span class="c1"># no suitable truth</span>
        <span class="c1"># return one wih the shortest proof, and among those the fewest</span>
        <span class="c1"># assumptions</span>
        <span class="n">best_judgment</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">suitable_truths</span><span class="p">,</span>
                            <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">truth</span><span class="p">:</span> <span class="p">(</span><span class="n">truth</span><span class="o">.</span><span class="n">proof</span><span class="p">()</span><span class="o">.</span><span class="n">num_steps</span><span class="p">(),</span>
                                               <span class="nb">len</span><span class="p">(</span><span class="n">truth</span><span class="o">.</span><span class="n">assumptions</span><span class="p">)))</span>
        <span class="c1"># Make sure we get the desired style (and labels) for the</span>
        <span class="c1"># assumptions and &#39;truth&#39;.</span>
        <span class="c1"># Although this looks vacuous, it will map an assumption of</span>
        <span class="c1"># any style to the assumption of the desired style.</span>
        <span class="n">assumptions_with_style</span> <span class="o">=</span> <span class="p">{</span><span class="n">assumption</span><span class="p">:</span> <span class="n">assumption</span> <span class="k">for</span>
                                  <span class="n">assumption</span> <span class="ow">in</span> <span class="n">assumptions_set</span><span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">best_judgment</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">_style_id</span> <span class="o">!=</span> <span class="n">expression</span><span class="o">.</span><span class="n">_style_id</span> <span class="ow">or</span>
                <span class="nb">any</span><span class="p">(</span><span class="n">assumption</span><span class="o">.</span><span class="n">_style_id</span> <span class="o">!=</span> <span class="n">assumptions_with_style</span><span class="p">[</span><span class="n">assumption</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">assumption</span> <span class="ow">in</span> <span class="n">best_judgment</span><span class="o">.</span><span class="n">assumptions</span><span class="p">)):</span>
            <span class="n">assumptions</span> <span class="o">=</span> <span class="p">[</span><span class="n">assumptions_with_style</span><span class="p">[</span><span class="n">assumption</span><span class="p">]</span> <span class="k">for</span> <span class="n">assumption</span> <span class="ow">in</span>
                           <span class="n">best_judgment</span><span class="o">.</span><span class="n">assumptions</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">best_judgment</span><span class="o">.</span><span class="n">with_matching_styles</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span>
                                                      <span class="n">assumptions</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">best_judgment</span></div>

<div class="viewcode-block" id="Judgment.forget_judgments"><a class="viewcode-back" href="../../../api/proveit.Judgment.html#proveit.Judgment.forget_judgments">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">forget_judgments</span><span class="p">():</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Forget all Judgment&#39;s and all Assumption proof objects.  This is</span>
<span class="sd">        used for demonstration purposes in the tutorial, but should not </span>
<span class="sd">        generally be needed.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proof</span> <span class="k">import</span> <span class="n">Assumption</span>
        <span class="n">Judgment</span><span class="o">.</span><span class="n">lookup_dict</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">Assumption</span><span class="o">.</span><span class="n">all_assumptions</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_checkedTruth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proof</span><span class="p">):</span>
        <span class="n">proven_truth</span> <span class="o">=</span> <span class="n">proof</span><span class="o">.</span><span class="n">proven_truth</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">proven_truth</span><span class="o">.</span><span class="n">is_usable</span><span class="p">():</span>
            <span class="n">proven_truth</span><span class="o">.</span><span class="n">raise_unusable_proof</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">proven_truth</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    def relabel(self, relabel_map):</span>
<span class="sd">        &#39;&#39;&#39;</span>
<span class="sd">        Performs a relabeling derivation step, deriving another Judgment</span>
<span class="sd">        from this Judgment, under the same assumptions, with relabeled</span>
<span class="sd">        Variables.  A Variable may only be relabeled to a Variable.</span>
<span class="sd">        Returns the proven relabeled Judgment, or throws an exception if the proof fails.</span>
<span class="sd">        &#39;&#39;&#39;</span>
<span class="sd">        from proveit._core_.proof import Specialization</span>
<span class="sd">        return self._checkedTruth(Specialization(self, num_forall_eliminations=0, relabel_map=relabel_map, assumptions=self.assumptions))</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Judgment.instantiate"><a class="viewcode-back" href="../../../api/proveit.Judgment.html#proveit.Judgment.instantiate">[docs]</a>    <span class="k">def</span> <span class="nf">instantiate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">repl_map</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">num_forall_eliminations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">assumptions</span><span class="o">=</span><span class="n">USE_DEFAULTS</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Performs an instantiation derivation step to be proven under the </span>
<span class="sd">        given assumptions, in addition to the assumptions of the </span>
<span class="sd">        Judgment.  This may instantiate Variables that are universally </span>
<span class="sd">        quantified immediately to the right of the Judgment turnstile</span>
<span class="sd">        according to the &quot;replacement&quot; map (repl_map), eliminating the </span>
<span class="sd">        quantifier as the corresponding variables are instantiated.</span>
<span class="sd">        It may eliminate any number of nested Forall operations, </span>
<span class="sd">        instantiating the instance Variables according to repl_map, </span>
<span class="sd">        going to the depth for which the instance variables occur as </span>
<span class="sd">        keys in repl_map or according to num_forall_eliminations if it</span>
<span class="sd">        is specified.</span>
<span class="sd">        </span>
<span class="sd">        For Variables that map to Variables in the replacement map,</span>
<span class="sd">        this is handled as a relabeling across both sides of the</span>
<span class="sd">        turnstile as well as &quot;internal&quot; Lambda map parameters.</span>
<span class="sd">        For Variables that map to non-Variables, the replacement only</span>
<span class="sd">        occurs within an eliminated quantifier and will not penetrate </span>
<span class="sd">        into internal Lambda maps that use that Variable as a parameter. </span>
<span class="sd">        </span>
<span class="sd">        Replacements are made simultaneously.  For example, the </span>
<span class="sd">        {x:y, y:x} mapping will swap x and y variables.</span>

<span class="sd">        Returns the proven instantiated Judgment, or throws an exception</span>
<span class="sd">        if the proof fails.  For the proof to succeed, all conditions of</span>
<span class="sd">        eliminated Forall operations, after replacements are made, must</span>
<span class="sd">        be proven.  Furthermore, there may be additional requirements </span>
<span class="sd">        when iterated parameters are instantiated (see Lambda.apply for</span>
<span class="sd">        details).  Automation mayb be used in attempting to prove these </span>
<span class="sd">        requirements provided proveit.defaults.automation=True.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit</span> <span class="k">import</span> <span class="p">(</span><span class="n">Variable</span><span class="p">,</span> <span class="n">Operation</span><span class="p">,</span> <span class="n">Conditional</span><span class="p">,</span> <span class="n">Lambda</span><span class="p">,</span>
                             <span class="n">single_or_composite_expression</span><span class="p">,</span>
                             <span class="n">ExprTuple</span><span class="p">,</span> <span class="n">IndexedVar</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">proveit._core_.expression.lambda_expr.lambda_expr</span> <span class="k">import</span> \
            <span class="n">get_param_var</span>
        <span class="kn">from</span> <span class="nn">proveit.logic</span> <span class="k">import</span> <span class="n">Forall</span>
        <span class="kn">from</span> <span class="nn">.proof</span> <span class="k">import</span> <span class="n">Instantiation</span><span class="p">,</span> <span class="n">ProofFailure</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_usable</span><span class="p">():</span>
            <span class="c1"># If this Judgment is not usable, see if there is an alternate</span>
            <span class="c1"># under the set of assumptions that is usable.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">alternate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">prove</span><span class="p">(</span><span class="n">assumptions</span><span class="p">,</span> <span class="n">automation</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">ProofFailure</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">raise_unusable_proof</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">alternate</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span><span class="n">repl_map</span><span class="p">,</span> <span class="n">assumptions</span><span class="p">)</span>

        <span class="c1"># If no repl_map is provided, instantiate the </span>
        <span class="c1"># &quot;explicit_instance_vars&quot; of the Forall with default mappings</span>
        <span class="c1"># (mapping instance variables to themselves)</span>
        <span class="k">if</span> <span class="n">repl_map</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">repl_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">ivar</span><span class="p">:</span> <span class="n">ivar</span> <span class="k">for</span> <span class="n">ivar</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">explicit_instance_vars</span><span class="p">()}</span>

        <span class="c1"># Include the Judgment assumptions along with any provided </span>
        <span class="c1"># assumptions</span>
        <span class="n">assumptions</span> <span class="o">=</span> <span class="n">defaults</span><span class="o">.</span><span class="n">checked_assumptions</span><span class="p">(</span><span class="n">assumptions</span><span class="p">)</span>

        <span class="c1"># For any entrys in repl_map with Operation keys, convert</span>
        <span class="c1"># them to corresponding operator keys with Lambda substitutions.</span>
        <span class="c1"># For example f(x,y):g(x,y) would become f:[(x,y) -&gt; g(x,y)].</span>
        <span class="c1"># And any ExprTuple-wrapped ExprRange entries will be</span>
        <span class="c1"># Also, convert to composite expressions as needed</span>
        <span class="c1"># (via single_or_composite_expression).</span>
        <span class="n">processed_repl_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">equiv_alt_expansions</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">replacement</span> <span class="ow">in</span> <span class="n">repl_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">replacement</span> <span class="o">=</span> <span class="n">single_or_composite_expression</span><span class="p">(</span><span class="n">replacement</span><span class="p">)</span>
            <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            if isinstance(replacement, ExprRange):</span>
<span class="sd">                raise TypeError(&quot;Not expecting an ExprRange for a replacement &quot;</span>
<span class="sd">                                &quot;when instantiating.  Got %s.  Perhaps it &quot;</span>
<span class="sd">                                &quot;should be wrapped in an ExprTuple.&quot;</span>
<span class="sd">                                %replacement)</span>
<span class="sd">            &#39;&#39;&#39;</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">IndexedVar</span><span class="p">):</span>
                <span class="n">processed_repl_map</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">replacement</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">ExprTuple</span><span class="p">)</span> <span class="ow">and</span> <span class="n">key</span><span class="o">.</span><span class="n">num_entries</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">param_entry</span> <span class="ow">in</span> <span class="n">key</span><span class="p">:</span>
                        <span class="n">get_param_var</span><span class="p">(</span><span class="n">param_entry</span><span class="p">)</span>
                <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not the expected kind of Expression &quot;</span>
                        <span class="s2">&quot;as a repl_map key:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                        <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">num_entries</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># Replacement key for replacing a range of indexed</span>
                    <span class="c1"># variables, or range of ranges of indexed variables</span>
                    <span class="c1"># , etc.</span>
                    <span class="n">processed_repl_map</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">replacement</span>
                    <span class="c1"># Although this is redundant (not really necessary</span>
                    <span class="c1"># as an entry in `equiv_alt_expansions` as far</span>
                    <span class="c1"># as Lambda.apply is concerned) it is useful for</span>
                    <span class="c1"># bookkeeping to extract all of the instantiation</span>
                    <span class="c1"># mappings:</span>
                    <span class="n">equiv_alt_expansions</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">replacement</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">key</span><span class="o">.</span><span class="n">num_entries</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span>
                    <span class="c1"># An &quot;alternative equivalent expansion&quot; of</span>
                    <span class="c1"># some range of indexed variables (or range of </span>
                    <span class="c1"># ranges, etc.).    For example,</span>
                    <span class="c1"># (x_i, x_{i+1}, ..., x_j).</span>
                    <span class="n">equiv_alt_expansions</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">replacement</span>
            <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">Operation</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">operator</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)):</span>
                <span class="n">operation</span> <span class="o">=</span> <span class="n">key</span>
                <span class="n">repl_var</span> <span class="o">=</span> <span class="n">operation</span><span class="o">.</span><span class="n">operator</span>
                <span class="n">replacement</span> <span class="o">=</span> <span class="n">Lambda</span><span class="p">(</span><span class="n">operation</span><span class="o">.</span><span class="n">operands</span><span class="p">,</span> <span class="n">replacement</span><span class="p">)</span>
                <span class="n">processed_repl_map</span><span class="p">[</span><span class="n">repl_var</span><span class="p">]</span> <span class="o">=</span> <span class="n">replacement</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not the expected kind of Expression as &quot;</span>
                    <span class="s2">&quot;a repl_map key.  Expecting repl_map keys to be &quot;</span>
                    <span class="s2">&quot;Variables, Operations with Variable operators &quot;</span>
                    <span class="s2">&quot;(for operation substitution), or an ExprTuple &quot;</span>
                    <span class="s2">&quot;containing a single iterated IndexedVar &quot;</span>
                    <span class="s2">&quot;like (x_i, ..., x_j).&quot;</span> <span class="o">%</span>
                    <span class="n">key</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">get_repl_var</span><span class="p">(</span><span class="n">repl_key</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">repl_key</span><span class="p">,</span> <span class="n">ExprTuple</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">get_param_var</span><span class="p">(</span><span class="n">repl_key</span><span class="o">.</span><span class="n">entries</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">get_param_var</span><span class="p">(</span><span class="n">repl_key</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">num_forall_eliminations</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Determine the number of Forall eliminations.</span>
            <span class="c1"># The number is determined by the instance variables that</span>
            <span class="c1"># occur as keys in repl_map.</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span>
            <span class="n">remaining_repl_vars</span> <span class="o">=</span> \
                <span class="p">{</span><span class="n">get_repl_var</span><span class="p">(</span><span class="n">repl_key</span><span class="p">)</span> <span class="k">for</span> <span class="n">repl_key</span>
                 <span class="ow">in</span> <span class="n">processed_repl_map</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
            <span class="n">forall_depth</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">num_forall_eliminations</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">remaining_repl_vars</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Forall</span><span class="p">):</span>
                    <span class="c1"># No more directly nested universal quantifiers</span>
                    <span class="k">break</span>  <span class="c1"># to eliminate.</span>
                <span class="n">lambda_expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">operand</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lambda_expr</span><span class="p">,</span> <span class="n">Lambda</span><span class="p">),</span> <span class="p">(</span>
                    <span class="s2">&quot;Forall Operation operand must be a Lambda function&quot;</span><span class="p">)</span>
                <span class="n">instance_param_vars</span> <span class="o">=</span> <span class="n">lambda_expr</span><span class="o">.</span><span class="n">parameter_vars</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">lambda_expr</span><span class="o">.</span><span class="n">body</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Conditional</span><span class="p">):</span>
                    <span class="c1"># Skip over the &quot;conditions&quot; of the Forall expression.</span>
                    <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">value</span>
                <span class="n">forall_depth</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">for</span> <span class="n">iparam_var</span> <span class="ow">in</span> <span class="n">instance_param_vars</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">iparam_var</span> <span class="ow">in</span> <span class="n">remaining_repl_vars</span><span class="p">:</span>
                        <span class="c1"># Remove this instance parameter variable from</span>
                        <span class="c1"># the remaining variables to replace.</span>
                        <span class="n">remaining_repl_vars</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">iparam_var</span><span class="p">)</span>
                        <span class="c1"># Eliminate to this depth at least since there</span>
                        <span class="c1"># is a replacement map for the instance</span>
                        <span class="c1"># variable:</span>
                        <span class="n">num_forall_eliminations</span> <span class="o">=</span> <span class="n">forall_depth</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># default is to map instance variables to</span>
                        <span class="c1"># themselves</span>
                        <span class="n">processed_repl_map</span><span class="p">[</span><span class="n">iparam_var</span><span class="p">]</span> <span class="o">=</span> <span class="n">iparam_var</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_checkedTruth</span><span class="p">(</span>
            <span class="n">Instantiation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                          <span class="n">num_forall_eliminations</span><span class="o">=</span><span class="n">num_forall_eliminations</span><span class="p">,</span>
                          <span class="n">repl_map</span><span class="o">=</span><span class="n">processed_repl_map</span><span class="p">,</span>
                          <span class="n">equiv_alt_expansions</span><span class="o">=</span><span class="n">equiv_alt_expansions</span><span class="p">,</span>
                          <span class="n">assumptions</span><span class="o">=</span><span class="n">assumptions</span><span class="p">))</span></div>

<div class="viewcode-block" id="Judgment.generalize"><a class="viewcode-back" href="../../../api/proveit.Judgment.html#proveit.Judgment.generalize">[docs]</a>    <span class="k">def</span> <span class="nf">generalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">forall_var_or_vars_or_var_lists</span><span class="p">,</span>
                   <span class="n">domain_lists</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">conditions</span><span class="o">=</span><span class="nb">tuple</span><span class="p">()):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Performs a generalization derivation step.  Returns the</span>
<span class="sd">        proven generalized Judgment.  Can introduce any number of</span>
<span class="sd">        nested Forall operations to wrap the original statement,</span>
<span class="sd">        corresponding to the number of given forall_var_lists and </span>
<span class="sd">        domains.  A single variable list or single variable and a single</span>
<span class="sd">        domain may be provided to introduce a single Forall wrapper.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit._core_.proof</span> <span class="k">import</span> <span class="n">Generalization</span>
        <span class="kn">from</span> <span class="nn">proveit._core_.expression.lambda_expr.lambda_expr</span> <span class="k">import</span> \
            <span class="n">valid_params</span>
        <span class="kn">from</span> <span class="nn">proveit._core_.expression.composite.composite</span> <span class="k">import</span> \
            <span class="n">composite_expression</span>
        <span class="kn">from</span> <span class="nn">proveit.logic</span> <span class="k">import</span> <span class="n">InSet</span>

        <span class="c1"># Convert all forms of `forall_var_or_vars_or_var_lists` to</span>
        <span class="c1"># forall_var_lists, the most general form.  Start with the</span>
        <span class="c1"># default:</span>
        <span class="n">forall_var_lists</span> <span class="o">=</span> <span class="n">forall_var_or_vars_or_var_lists</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">forall_vars</span> <span class="o">=</span> <span class="n">composite_expression</span><span class="p">(</span><span class="n">forall_var_or_vars_or_var_lists</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">valid_params</span><span class="p">(</span><span class="n">forall_vars</span><span class="p">):</span>
                <span class="n">forall_var_lists</span> <span class="o">=</span> <span class="p">[</span><span class="n">forall_vars</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">BaseException</span><span class="p">:</span>
            <span class="k">pass</span>  <span class="c1"># don&#39;t change the default</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">forall_var_lists</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must supply &#39;generalize&#39; with a Variable, &quot;</span>
                             <span class="s2">&quot;list of Variables (or variable ranges), or &quot;</span>
                             <span class="s2">&quot;list of lists of Variables (or variable &quot;</span>
                             <span class="s2">&quot;ranges).&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">forall_var_lists</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Must provide at least one Variable to generalize over&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">forall_var_list</span> <span class="ow">in</span> <span class="n">forall_var_lists</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">forall_var_lists</span><span class="p">,</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;`forall_var_lists` must be a list of lists specifying &quot;</span>
                    <span class="s2">&quot;instance parameters of forall operations to &quot;</span>
                    <span class="s2">&quot;introduce (or, for convenience it may be a single &quot;</span>
                    <span class="s2">&quot;variable)&quot;</span><span class="p">)</span>

        <span class="c1"># Add domain conditions as appropriate</span>
        <span class="k">if</span> <span class="n">domain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">domain_lists</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Either specify a `domain` or &quot;</span>
                             <span class="s2">&quot;&#39;domain_lists&#39; but not both&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">domain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">domain_lists</span> <span class="o">=</span> <span class="p">[[</span><span class="n">domain</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">forall_var_lists</span><span class="p">)</span> <span class="k">for</span>
                            <span class="n">forall_var_list</span> <span class="ow">in</span> <span class="n">forall_var_lists</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">domain_lists</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">domain_conditions</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">domain_list</span><span class="p">,</span> <span class="n">forall_var_list</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">domain_lists</span><span class="p">,</span>
                                                    <span class="n">forall_var_lists</span><span class="p">):</span>
                <span class="n">domains</span> <span class="o">=</span> <span class="n">composite_expression</span><span class="p">(</span><span class="n">domain_list</span><span class="p">)</span>
                <span class="n">forall_vars</span> <span class="o">=</span> <span class="n">composite_expression</span><span class="p">(</span><span class="n">forall_var_list</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">domains</span><span class="o">.</span><span class="n">num_entries</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">domains</span> <span class="o">=</span> <span class="p">[</span><span class="n">domain_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="n">forall_vars</span><span class="o">.</span><span class="n">num_entries</span><span class="p">()</span>
                <span class="n">domain_conditions</span> <span class="o">+=</span> <span class="p">[</span><span class="n">InSet</span><span class="p">(</span><span class="n">instance_var</span><span class="p">,</span> <span class="n">domain</span><span class="p">)</span> <span class="k">for</span>
                                      <span class="n">instance_var</span><span class="p">,</span> <span class="n">domain</span> <span class="ow">in</span>
                                      <span class="nb">zip</span><span class="p">(</span><span class="n">forall_vars</span><span class="p">,</span> <span class="n">domains</span><span class="p">)]</span>
            <span class="n">conditions</span> <span class="o">=</span> <span class="n">domain_conditions</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">conditions</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_checkedTruth</span><span class="p">(</span><span class="n">Generalization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">forall_var_lists</span><span class="p">,</span>
                                                 <span class="n">conditions</span><span class="p">))</span></div>

<div class="viewcode-block" id="Judgment.as_implication"><a class="viewcode-back" href="../../../api/proveit.Judgment.html#proveit.Judgment.as_implication">[docs]</a>    <span class="k">def</span> <span class="nf">as_implication</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hypothesis</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Performs a &quot;deduction&quot; derivation step, forming an implication</span>
<span class="sd">        statement with the given hypothesis and self.expr</span>
<span class="sd">        as the conclusion.  The hypothesis is removed from the set of</span>
<span class="sd">        the conclusion statement&#39;s assumptions for the implication</span>
<span class="sd">        statement&#39;s assumptions.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit._core_.proof</span> <span class="k">import</span> <span class="n">Deduction</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hypothesis</span><span class="p">,</span> <span class="n">Judgment</span><span class="p">):</span>
            <span class="n">hypothesis</span> <span class="o">=</span> <span class="n">hypothesis</span><span class="o">.</span><span class="n">expr</span>  <span class="c1"># we want the expression for this purpose</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_checkedTruth</span><span class="p">(</span><span class="n">Deduction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hypothesis</span><span class="p">))</span></div>

<div class="viewcode-block" id="Judgment.eliminate"><a class="viewcode-back" href="../../../api/proveit.Judgment.html#proveit.Judgment.eliminate">[docs]</a>    <span class="k">def</span> <span class="nf">eliminate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">skolem_constants</span><span class="p">,</span> <span class="n">assumptions</span><span class="o">=</span><span class="n">USE_DEFAULTS</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Performs a Skolem constant elimination derivation step on this</span>
<span class="sd">        Judgment (KT), where this KT has the form S |– alpha and the</span>
<span class="sd">        set S of assumptions includes one or more assumptions involving</span>
<span class="sd">        one or more Skolem constants sk1, …, skn specified by</span>
<span class="sd">        skolem_constants, where the Skolem constant-related assumptions</span>
<span class="sd">        were previously generated using the Exists.choose(sk1, …, skn)</span>
<span class="sd">        method.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.logic</span> <span class="k">import</span> <span class="n">Exists</span>
        <span class="k">return</span> <span class="n">Exists</span><span class="o">.</span><span class="n">eliminate</span><span class="p">(</span><span class="n">skolem_constants</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">assumptions</span><span class="p">)</span></div>

<div class="viewcode-block" id="Judgment.evaluation"><a class="viewcode-back" href="../../../api/proveit.Judgment.html#proveit.Judgment.evaluation">[docs]</a>    <span class="k">def</span> <span class="nf">evaluation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assumptions</span><span class="o">=</span><span class="n">USE_DEFAULTS</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Calling evaluation on a Judgment results in deriving that its</span>
<span class="sd">        expression is equal to TRUE, under the assumptions of the </span>
<span class="sd">        Judgment.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.logic</span> <span class="k">import</span> <span class="n">evaluate_truth</span>
        <span class="k">return</span> <span class="n">evaluate_truth</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">assumptions</span><span class="p">)</span></div>

<div class="viewcode-block" id="Judgment.as_impl"><a class="viewcode-back" href="../../../api/proveit.Judgment.html#proveit.Judgment.as_impl">[docs]</a>    <span class="k">def</span> <span class="nf">as_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hypothesis</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Abbreviation for as_implication.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_implication</span><span class="p">(</span><span class="n">hypothesis</span><span class="p">)</span></div>

<div class="viewcode-block" id="Judgment.raise_unusable_proof"><a class="viewcode-back" href="../../../api/proveit.Judgment.html#proveit.Judgment.raise_unusable_proof">[docs]</a>    <span class="k">def</span> <span class="nf">raise_unusable_proof</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.proof</span> <span class="k">import</span> <span class="n">UnusableProof</span>
        <span class="n">proof</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proof</span><span class="p">()</span>
        <span class="n">unusuable_proof</span> <span class="o">=</span> <span class="n">proof</span><span class="o">.</span><span class="n">_meaning_data</span><span class="o">.</span><span class="n">_unusable_proof</span>
        <span class="k">if</span> <span class="n">proof</span> <span class="o">==</span> <span class="n">unusuable_proof</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">UnusableProof</span><span class="p">(</span><span class="n">Judgment</span><span class="o">.</span><span class="n">theorem_being_proven</span><span class="p">,</span> <span class="n">unusuable_proof</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">UnusableProof</span><span class="p">(</span>
                <span class="n">Judgment</span><span class="o">.</span><span class="n">theorem_being_proven</span><span class="p">,</span>
                <span class="n">unusuable_proof</span><span class="p">,</span>
                <span class="s1">&#39;required to prove&#39;</span> <span class="o">+</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">(</span>
                    <span class="n">perform_usability_check</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span></div>

<div class="viewcode-block" id="Judgment.string"><a class="viewcode-back" href="../../../api/proveit.Judgment.html#proveit.Judgment.string">[docs]</a>    <span class="k">def</span> <span class="nf">string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">perform_usability_check</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Display the turnstile notation to show that the judgment</span>
<span class="sd">        on the right derives from the set of assumptions on the left.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit</span> <span class="k">import</span> <span class="n">ExprTuple</span>
        <span class="k">if</span> <span class="n">perform_usability_check</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_usable</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">raise_unusable_proof</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">assumptions</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">assumptions_str</span> <span class="o">=</span> <span class="n">ExprTuple</span><span class="p">(</span>
                <span class="o">*</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">assumptions</span><span class="p">)</span><span class="o">.</span><span class="n">formatted</span><span class="p">(</span>
                <span class="s1">&#39;string&#39;</span><span class="p">,</span>
                <span class="n">fence</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">return</span> <span class="sa">r</span><span class="s1">&#39;{&#39;</span> <span class="o">+</span> <span class="n">assumptions_str</span> <span class="o">+</span> <span class="sa">r</span><span class="s1">&#39;} |- &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">string</span><span class="p">()</span>
        <span class="k">return</span> <span class="sa">r</span><span class="s1">&#39;|- &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">string</span><span class="p">()</span></div>

<div class="viewcode-block" id="Judgment.latex"><a class="viewcode-back" href="../../../api/proveit.Judgment.html#proveit.Judgment.latex">[docs]</a>    <span class="k">def</span> <span class="nf">latex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">perform_usability_check</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Display the turnstile notation to show that the judgment</span>
<span class="sd">        on the right derives from the set of assumptions on the left.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit</span> <span class="k">import</span> <span class="n">ExprTuple</span>
        <span class="k">if</span> <span class="n">perform_usability_check</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_usable</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">raise_unusable_proof</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">assumptions</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">assumptions_latex</span> <span class="o">=</span> <span class="n">ExprTuple</span><span class="p">(</span>
                <span class="o">*</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">assumptions</span><span class="p">)</span><span class="o">.</span><span class="n">formatted</span><span class="p">(</span>
                <span class="s1">&#39;latex&#39;</span><span class="p">,</span>
                <span class="n">fence</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">return</span> <span class="sa">r</span><span class="s1">&#39;{&#39;</span> <span class="o">+</span> <span class="n">assumptions_latex</span> <span class="o">+</span> <span class="sa">r</span><span class="s1">&#39;} \vdash &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">latex</span><span class="p">()</span>
        <span class="k">return</span> <span class="sa">r</span><span class="s1">&#39;\vdash &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">latex</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return a string representation of the Judgment.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return a string representation of the Judgment.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_usable</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">raise_unusable_proof</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_repr_html_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Generate html to show the Judgment as a set of assumptions,</span>
<span class="sd">        turnstile, then the statement expression.  Expressions are png&#39;s</span>
<span class="sd">        compiled from the latex (that may be recalled from memory or</span>
<span class="sd">        storage if previously generated) with a links to</span>
<span class="sd">        expr.ipynb notebooks for displaying the expression information.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">defaults</span><span class="o">.</span><span class="n">display_latex</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>  <span class="c1"># No LaTeX display at this time.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_usable</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">raise_unusable_proof</span><span class="p">()</span>
        <span class="n">html</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="n">proof</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proof</span><span class="p">()</span>
        <span class="n">html</span> <span class="o">+=</span> <span class="s1">&#39;&lt;span style=&quot;font-size:20px;&quot;&gt;&#39;</span>
        <span class="n">html</span> <span class="o">+=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">assumption</span><span class="o">.</span><span class="n">_repr_html_</span><span class="p">()</span> <span class="k">for</span> <span class="n">assumption</span>
                          <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">assumptions</span><span class="p">)</span>
        <span class="n">html</span> <span class="o">+=</span> <span class="s1">&#39; &#39;</span>
        <span class="k">if</span> <span class="n">proof</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># link to the proof</span>
            <span class="n">html</span> <span class="o">+=</span> <span class="p">(</span><span class="s1">&#39;&lt;a class=&quot;ProveItLink&quot; &#39;</span>
                     <span class="s1">&#39;href=&quot;</span><span class="si">%s</span><span class="s1">&quot; style=&quot;text-decoration: none&quot;&gt;&#39;</span> 
                     <span class="o">%</span> <span class="n">proof</span><span class="o">.</span><span class="n">get_link</span><span class="p">())</span>
        <span class="n">html</span> <span class="o">+=</span> <span class="s1">&#39;&amp;nbsp;&amp;#x22A2;&amp;nbsp;&amp;nbsp;&#39;</span>  <span class="c1"># turnstile symbol</span>
        <span class="k">if</span> <span class="n">proof</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">html</span> <span class="o">+=</span> <span class="s1">&#39;&lt;/a&gt;&#39;</span>
        <span class="n">html</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">_repr_html_</span><span class="p">()</span>
        <span class="n">html</span> <span class="o">+=</span> <span class="s1">&#39;&lt;/span&gt;&#39;</span>
        <span class="k">return</span> <span class="n">html</span>

<div class="viewcode-block" id="Judgment.inner_expr"><a class="viewcode-back" href="../../../api/proveit.Judgment.html#proveit.Judgment.inner_expr">[docs]</a>    <span class="k">def</span> <span class="nf">inner_expr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return an InnerExpr object to wrap the Judgment and</span>
<span class="sd">        access any inner sub-expression (including assumptions or</span>
<span class="sd">        inner expressions of assumptions) for the purpose of</span>
<span class="sd">        replacing the inner expression, changing its style,</span>
<span class="sd">        or relabeling variables.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">.expression.inner_expr</span> <span class="k">import</span> <span class="n">InnerExpr</span>
        <span class="k">return</span> <span class="n">InnerExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="as_expression"><a class="viewcode-back" href="../../../api/proveit.as_expression.html#proveit.as_expression">[docs]</a><span class="k">def</span> <span class="nf">as_expression</span><span class="p">(</span><span class="n">truth_or_expression</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Return the argument as Expressions.  That is, if the argument is the</span>
<span class="sd">    Judgment, yield its associated Expression.  If it is an Expression,</span>
<span class="sd">    yield just that.  Otherwise, raise a TypeError.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">truth_or_expression</span><span class="p">,</span> <span class="n">Judgment</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">truth_or_expression</span><span class="o">.</span><span class="n">expr</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">truth_or_expression</span><span class="p">,</span> <span class="n">Expression</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">truth_or_expression</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Expected to be a Judgment or an Expression&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="as_expressions"><a class="viewcode-back" href="../../../api/proveit.as_expressions.html#proveit.as_expressions">[docs]</a><span class="k">def</span> <span class="nf">as_expressions</span><span class="p">(</span><span class="o">*</span><span class="n">truth_or_expressions</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Return the arguments as a list of Expressions via as_expression.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">as_expression</span><span class="p">(</span><span class="n">truth_or_expression</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">truth_or_expression</span> <span class="ow">in</span> <span class="n">truth_or_expressions</span><span class="p">]</span></div>


<span class="k">class</span> <span class="nc">ProofInitiationFailure</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">message</span> <span class="o">=</span> <span class="n">message</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">message</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">Prove-It</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.as_expression.html">as_expression</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.as_expressions.html">as_expressions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.attempt_to_simplify.html">attempt_to_simplify</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.bundle.html">bundle</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.composite_expression.html">composite_expression</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.expression_depth.html">expression_depth</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.extract_var_tuple_indices.html">extract_var_tuple_indices</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.free_vars.html">free_vars</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.maybe_fenced.html">maybe_fenced</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.maybe_fenced_latex.html">maybe_fenced_latex</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.maybe_fenced_string.html">maybe_fenced_string</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.possibly_free_var_ranges.html">possibly_free_var_ranges</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.reset.html">reset</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.safe_default_or_dummy_var.html">safe_default_or_dummy_var</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.safe_dummy_var.html">safe_dummy_var</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.safe_dummy_vars.html">safe_dummy_vars</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.single_or_composite_expression.html">single_or_composite_expression</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.total_ordering.html">total_ordering</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.traverse_inner_expressions.html">traverse_inner_expressions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.unbundle.html">unbundle</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.used_vars.html">used_vars</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.var_range.html">var_range</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.ArgumentExtractionError.html">ArgumentExtractionError</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.Assumption.html">Assumption</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.Axiom.html">Axiom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.Composite.html">Composite</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.Conditional.html">Conditional</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.ConditionalSet.html">ConditionalSet</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.Deduction.html">Deduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.DisallowedParameterRelabeling.html">DisallowedParameterRelabeling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.DuplicateLiteralError.html">DuplicateLiteralError</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.ExprArray.html">ExprArray</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.ExprRange.html">ExprRange</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.ExprTuple.html">ExprTuple</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.ExprTupleError.html">ExprTupleError</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.Expression.html">Expression</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.Function.html">Function</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.Generalization.html">Generalization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.GeneralizationFailure.html">GeneralizationFailure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.ImproperReplacement.html">ImproperReplacement</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.IndexedVar.html">IndexedVar</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.InnerExpr.html">InnerExpr</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.Instantiation.html">Instantiation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.InstantiationFailure.html">InstantiationFailure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.InvalidAssumptions.html">InvalidAssumptions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.Judgment.html">Judgment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.Label.html">Label</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.Lambda.html">Lambda</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.LambdaApplicationError.html">LambdaApplicationError</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.Literal.html">Literal</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.MakeNotImplemented.html">MakeNotImplemented</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.ModusPonens.html">ModusPonens</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.ModusPonensFailure.html">ModusPonensFailure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.NamedExprs.html">NamedExprs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.Operation.html">Operation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.OperationError.html">OperationError</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.OperationOverInstances.html">OperationOverInstances</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.ParameterCollisionError.html">ParameterCollisionError</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.Proof.html">Proof</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.ProofFailure.html">ProofFailure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.RangeInstanceError.html">RangeInstanceError</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.StyleOptions.html">StyleOptions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.Theorem.html">Theorem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.Theory.html">Theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.TheoryException.html">TheoryException</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.TheoryPackage.html">TheoryPackage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.TransRelUpdater.html">TransRelUpdater</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.TransitiveRelation.html">TransitiveRelation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.TransitivityException.html">TransitivityException</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.UnusableProof.html">UnusableProof</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.Variable.html">Variable</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.core_expr_types.Len.html">Len</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.compose.html">compose</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.conclude_via_implication.html">conclude_via_implication</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.default_simplification.html">default_simplification</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.evaluate_truth.html">evaluate_truth</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.in_bool.html">in_bool</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.is_irreducible_value.html">is_irreducible_value</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.not_proper_superset.html">not_proper_superset</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.not_superset_eq.html">not_superset_eq</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.proper_superset.html">proper_superset</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.reduce_operands.html">reduce_operands</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.superset_eq.html">superset_eq</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.And.html">And</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.BooleanSet.html">BooleanSet</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.Card.html">Card</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.Difference.html">Difference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.Disjoint.html">Disjoint</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.Distinct.html">Distinct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.Equals.html">Equals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.EvaluationError.html">EvaluationError</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.Exists.html">Exists</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.FalseLiteral.html">FalseLiteral</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.Forall.html">Forall</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.Iff.html">Iff</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.Implies.html">Implies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.InSet.html">InSet</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.Intersect.html">Intersect</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.IntersectAll.html">IntersectAll</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.IrreducibleValue.html">IrreducibleValue</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.Membership.html">Membership</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.Nonmembership.html">Nonmembership</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.Not.html">Not</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.NotEquals.html">NotEquals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.NotExists.html">NotExists</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.NotInSet.html">NotInSet</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.NotProperSubset.html">NotProperSubset</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.NotSubsetEq.html">NotSubsetEq</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.Or.html">Or</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.PowerSet.html">PowerSet</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.ProperSubset.html">ProperSubset</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.Set.html">Set</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.SetEquiv.html">SetEquiv</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.SetNotEquiv.html">SetNotEquiv</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.SetOfAll.html">SetOfAll</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.SimplificationError.html">SimplificationError</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.StrictSubset.html">StrictSubset</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.SubsetEq.html">SubsetEq</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.SubsetProper.html">SubsetProper</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.TrueLiteral.html">TrueLiteral</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.Union.html">Union</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.UnionAll.html">UnionAll</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.numbers.const_shift_composition.html">const_shift_composition</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.numbers.const_shift_decomposition.html">const_shift_decomposition</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.numbers.dist_add.html">dist_add</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.numbers.dist_subtract.html">dist_subtract</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.numbers.frac.html">frac</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.numbers.greater.html">greater</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.numbers.greater_eq.html">greater_eq</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.numbers.is_literal_int.html">is_literal_int</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.numbers.num.html">num</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.numbers.number_ordering.html">number_ordering</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.numbers.sqrt.html">sqrt</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.numbers.subtract.html">subtract</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.numbers.Abs.html">Abs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.numbers.Add.html">Add</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.numbers.Ceil.html">Ceil</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.numbers.DecimalSequence.html">DecimalSequence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.numbers.Div.html">Div</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.numbers.Divides.html">Divides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.numbers.DividesProper.html">DividesProper</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.numbers.Exp.html">Exp</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.numbers.Floor.html">Floor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.numbers.GCD.html">GCD</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.numbers.Integrate.html">Integrate</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.numbers.Interval.html">Interval</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.numbers.IntervalCC.html">IntervalCC</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.numbers.IntervalCO.html">IntervalCO</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.numbers.IntervalOC.html">IntervalOC</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.numbers.IntervalOO.html">IntervalOO</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.numbers.Less.html">Less</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.numbers.LessEq.html">LessEq</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.numbers.Max.html">Max</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.numbers.Min.html">Min</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.numbers.Mod.html">Mod</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.numbers.ModAbs.html">ModAbs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.numbers.Mult.html">Mult</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.numbers.Neg.html">Neg</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.numbers.Numeral.html">Numeral</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.numbers.Prod.html">Prod</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.numbers.RealInterval.html">RealInterval</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.numbers.Round.html">Round</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.numbers.Sum.html">Sum</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  <li><a href="../../proveit.html">proveit</a><ul>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, Wayne Witzel.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.3.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>