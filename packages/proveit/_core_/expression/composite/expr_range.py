from proveit._core_.expression.expr import (Expression, MakeNotImplemented,
                                            ImproperReplacement, 
                                            DisallowedIndexing)
from proveit._core_.expression.lambda_expr.lambda_expr import Lambda
from proveit._core_.expression.composite import singularExpression, ExprTuple
from proveit._core_.expression.conditional import Conditional
from proveit._core_.proof import ProofFailure
from proveit._core_.defaults import defaults, USE_DEFAULTS

class ExprRange(Expression):
    '''
    An ExprRange expression represents a range of "element" expressions
    within a containing ExprTuple.  It represents this as a Lambda to 
    map each valid index value to a corresponding element, along with a
    start and end index value.  The represented element sequence 
    corresponds to index values going from the start to the end in 
    increments of 1, ranging over index values.
    
    For example,
    1/i + ... + 1/j
    is internall represented by an Add operation with the following as 
    its "operands":
    (1/i, ..., 1/j).
    These "operands" are represented by an ExprTuple with a single 
    "entry" which is an ExprRange whose `lambda_map` is "k |-> 1/k", 
    `start_index` is "i", and `end_index` is "j".  An ExprTuple "entry" 
    may generally either be a singuler element or an ExprRange that 
    represents multiple elements.
    '''

    def __init__(self, parameter, body, start_index, end_index, 
                 lambda_map=None):
        '''
        Create an ExprRange that represents a range of expressions
        to be embedded within an ExprTuple.  Each element of the
        range is generated by mapping the parameter according to the
        body with the parameter ranging from the start index to the
        end index. 
        A Lambda expression will be created as its first sub-expression.
        The start and end indices with be the second and third
        sub-expressions.
        
        The lambda_map may be used instead of supplying the parameter 
        and body, in which case the 'parameter' and 'body' arguments
        must both be None.
        '''
        if lambda_map is not None:
            # Use the provided 'lambda_map' instead of creating one.
            lambda_map = lambda_map
            if (parameter, body) != (None, None):
                raise ValueError("'parameter' and 'body' arguments of the "
                                 "ExprRange constructor should be None if "
                                 "lambda_map is provided.")
            parameter = lambda_map.parameter
        else:
            lambda_map = Lambda(parameter, body)
        
        Expression.__init__(self, ['ExprRange'], 
                            [lambda_map, start_index, end_index])
        self.start_index = singularExpression(start_index)
        self.end_index = singularExpression(end_index)
        self.lambda_map = lambda_map
        # The body of the Lambda map is a Conditional that conditions the 
        # mapping according to the parameter being in the [start, end] 
        # interval.  We'll use self.body to refer to the value of this
        # conditional.
        self.parameter = self.lambda_map.parameter
        self.body = self.lambda_map.body
    
    @classmethod
    def _make(subClass, coreInfo, styles, subExpressions):
        if subClass != ExprRange: 
            MakeNotImplemented(subClass)
        if len(coreInfo) != 1 or coreInfo[0] != 'ExprRange':
            raise ValueError("Expecting ExprRange coreInfo to contain "
                             "exactly one item: 'ExprRange'")
        lambda_map, start_index, end_index = subExpressions
        return ExprRange(None, None, start_index, end_index, 
                         lambda_map=lambda_map) \
                .withStyles(**styles)
            
    def remakeArguments(self):
        '''
        Yield the argument values or (name, value) pairs
        that could be used to recreate the ExprRange.
        '''
        yield self.lambda_map.parameter
        yield self.lambda_map.body
        yield self.start_index
        yield self.end_index
        
    def first(self):
        '''
        Return the first instance of the range 
        (and store for future use).
        '''
        if not hasattr(self, '_first'):
            expr_map = {self.lambda_map.parameter:self.start_index}
            self._first =  self.body.replaced(expr_map)
        return self._first

    def last(self):
        '''
        Return the last instance of the range 
        (and store for future use).
        '''
        if not hasattr(self, '_last'):
            expr_map = {self.lambda_map.parameter:self.end_index}
            self._last = self.body.replaced(expr_map)
        return self._last
    
    def start_indices(self):
        '''
        Return a list of starting indices, one for each nested
        ExprRange.  For example,
            (x_{m, i_{m}}, ..., x_{m, j_{m}}, ......,
             x_{n, i_{n}}, ..., x_{n, j_{n}}).
        has start indices (m, i_m).      
        '''
        indices = []
        expr = self
        repl_map = dict()
        while isinstance(expr, ExprRange):
            start_index = expr.start_index
            subbed_index = start_index.replaced(repl_map)
            indices.append(subbed_index)
            repl_map[self.parameter] = subbed_index
            expr = expr.body
        return indices
    
    def end_indices(self):
        '''
        Return a list of ending indices, one for each nested
        ExprRange.  For example,
            (x_{m, i_{m}}, ..., x_{m, j_{m}}, ......,
             x_{n, i_{n}}, ..., x_{n, j_{n}}).
        has end indices (n, j_n).      
        '''
        indices = []
        expr = self
        repl_map = dict()
        while isinstance(expr, ExprRange):
            end_index = expr.end_index
            subbed_index = end_index.replaced(repl_map)
            indices.append(subbed_index)
            repl_map[self.parameter] = subbed_index
            expr = expr.body
        return indices
    
    def string(self, **kwargs):
        return self.formatted('string', **kwargs)

    def latex(self, **kwargs):
        return self.formatted('latex', **kwargs)
    
    def nested_range_depth(self):
        '''
        Return the depth of nested ranges.  For example, if this
        is a simple range with no nesting, return 1.
        If this is a range of simple ranges, return 2.
        If this is a range of ranges of simple ranges, return 3.
        '''
        depth = 1
        expr = self.body
        while isinstance(expr, ExprRange):
            depth += 1
            expr = expr.body
        return depth
        
    def formatted(self, formatType, fence=False, subFence=True, 
                  operator=None, **kwargs):
        if operator is None:
             # comma is the default formatted operator
            formatted_operator = ','
        elif isinstance(operator, str):
            formatted_operator = operator
        else:
            formatted_operator = operator.formatted(formatType)
        formatted_sub_expressions = \
            [subExpr.formatted(formatType, fence=subFence) 
             for subExpr in (self.first(), self.last())]
        ellipsis = ('\ldots' if formatType=='latex' 
                                             else '...')
        # When ranges are nested, double-up (or triple-up, etc)
        # the ellipsis to make the nested structure clear.
        ellipses = ellipsis*self.nested_range_depth()
        
        formatted_sub_expressions.insert(1, ellipses)
        # Normally the range will be wrapped in an ExprTuple and 
        # fencing will be handled externally.  When it isn't, we don't 
        # want to fence it  anyway.
        return formatted_operator.join(formatted_sub_expressions)
    
    def getInstance(self, index, assumptions = USE_DEFAULTS, 
                    requirements = None):
        '''
        Return the range instance with the given Lambda map
        index as an Expression, using the given assumptions as 
        needed to interpret the index expression.  Required
        truths, proven under the given assumptions, that 
        were used to make this interpretation will be
        appended to the given 'requirements' (if provided).
        '''
        from proveit.number import LessEq
        
        if requirements is None:
            # requirements won't be passed back in this case 
            requirements = [] 
        
        # first make sure that the indices are in the range
        start_index, end_index = self.start_index, self.end_index
        for first, second in ((start_index, index), (index, end_index)):
            relation = None
            try:
                relation = LessEq.sort([first, second], reorder=False, 
                                       assumptions=assumptions)
            except:
                raise RangeInstanceError(
                        "Indices not provably within the range "
                        "range: %s <= %s"%(first, second)) 
            requirements.append(relation)
        
        # map to the desired instance
        return self.lambda_map.apply(index, assumptions=assumptions,
                                     requirements=requirements)

    def _free_var_ranges(self, exclusions=None):
        '''
        Return the dictionary mapping Variables to forms w.r.t. ranges
        of indices (or solo) in which the variable occurs as free or 
        not explicitly and completely masked.  Examples of "forms":
            x
            x_i
            x_1, ..., x_n
            x_{i, 1}, ..., x_{i, n_i}
            x_{1, 1}, ..., x_{1, n_1}, ......, x_{m, 1}, ..., x_{m, n_m}
        
        If this Expression is in the exclusion set, or contributes 
        directly to a form that is in the exclusions set, skip over it.
        For example, given the expression
            a*x_{i, 1} + ... + a*x_{i, n_1}
        if x_{i, 1}, ..., x_{i, n_i} is in the exclusion set,
        then 'a' will be the only free variable reported.
        '''
        from proveit._core_.expression.lambda_expr.lambda_expr import \
            getParamVar        
        if exclusions is not None:
            if self in exclusions:
                return dict() # this is excluded
            # For the body, extent the exclusion set as necessary to
            # exclude anything contributing directly to a form that is
            # in the exclusion set.  For example, if 
            # x_1, ..., x_n is in the exclusion set and 
            # self.parameter==k and self.start_index==1 and 
            # self.end_index==n then add x_k to the exclusion set of 
            # this body.
            body_exclusions = set(exclusions)
            for exclusion in exclusions:
                if (isinstance(exclusion, ExprRange) and
                        exclusion.start_index == self.start_index and
                        exclusion.end_index == self.end_index):
                    new_exclusion = exclusion.body.replaced(
                            {exclusion.parameter:self.parameter})
                    body_exclusions.add(new_exclusion)
        else:
            body_exclusions = None
        body_forms_dict = \
            self.body._free_var_ranges(exclusions=body_exclusions)
        forms_dict = dict(body_forms_dict)
        for expr in self._subExpressions:
            if expr == self.body: continue # already did that one
            for var, forms in \
                    expr._free_var_ranges(exclusions=exclusions).items():
                forms_dict.setdefault(var, set()).update(forms)        
        param = self.parameter
        # Eliminate the parameter; it is not a free variable.
        if param in forms_dict.keys():
            forms_dict[param].discard(param)
            if len(forms_dict[param])==0:
                forms_dict.pop(param)        
        # The var ranges of the body that depend upon self.parameter
        # will be promoted to expression ranges over the range of this 
        # ExprRange.  For example, if x_k is one of the var ranges of
        # the body and self.parameter==k, then x_k will be replaced
        # by x_1, ..., x_n.
        for parameterized_var_range in self._parameterized_var_ranges(
                body_forms_dict):
            var = getParamVar(parameterized_var_range)
            assert var in forms_dict
            forms_dict[var].remove(parameterized_var_range)
            forms_dict[var].add(ExprRange(param, parameterized_var_range,
                                         self.start_index, self.end_index))
        return forms_dict
        
    def _parameterized_var_ranges(self, body_forms_dict=None):
        '''
        Yield each of body._free_var_ranges() that involves the
        ExprRange parameter as a free variable.
        For example, for ((x_1 < x_{1+1}) and ... and (x_n < x_{n+1})),
        the following will be yielded if k is the ExprRange parameter:
            x_k, x_{k+1}.
        Another example:
            a*x_{1, 1} + ... + a*x_{1, n_1} + ...... 
                + a*x_{m, 1} + ... + a*x_{m, n_1}
        will give
            x_{i, 1}, ..., x_{i, n_i}
        if i is the ExprRange parameter.
        '''
        if body_forms_dict is None:
            body_forms_dict = self.body._free_var_ranges()
        param = self.parameter
        for var, forms in body_forms_dict.items():
            for form in forms:
                if form==self: continue
                if form==self.parameter: 
                    continue # don't count the parameter itself.
                var_forms_of_form = form._free_var_ranges()
                if (param in var_forms_of_form
                        and param in var_forms_of_form[param]):
                    yield form
    
    def _possibly_reduced_range(self, expr_range, assumptions, requirements):
        from proveit import KnownTruth
        from proveit._common_ import f, i, j
        from proveit.logic import Equals
        from proveit.number import Add, one
        if not defaults.automation:
            # If automation is off, we won't do any reduction.
            yield expr_range
            return
        lambda_map = expr_range.lambda_map
        start_index = expr_range.start_index
        end_index = expr_range.end_index
        if defaults.reduce_singular_ranges and start_index == end_index:
            # We can do a singular range reduction.
            # Temporarily disable automation to avoid infinite
            # recursion.
            from proveit.core_expr_types.tuples._theorems_ import \
                singular_range_reduction
            defaults.automation = False
            try:
                reduction = singular_range_reduction.instantiate(
                        {f:lambda_map, i:start_index})
            finally:
                # Re-enable automation.
                defaults.automation = True
        elif (defaults.reduce_empty_ranges and 
              Equals(Add(end_index, one), start_index).proven(assumptions)):
            # We can do an empty range reduction
            # Temporarily disable automation to avoid infinite
            # recursion.
            from proveit.core_expr_types.tuples._axioms_ import empty_range_def
            defaults.automation = False
            try:
                reduction = empty_range_def.instantiate(
                        {f:lambda_map, i:start_index, j:end_index})
            finally:
                # Re-enable automation.
                defaults.automation = True                
        else:
            yield expr_range # no reduction
            return
        assert isinstance(reduction, KnownTruth)
        assert isinstance(reduction.expr, Equals)
        assert len(reduction.expr.operands) == 2
        assert reduction.expr.operands[0] == ExprTuple(expr_range)
        reduced_tuple = reduction.expr.operands[1]
        assert isinstance(reduced_tuple, ExprTuple)
        requirements.append(reduction)
        for entry in reduced_tuple:
            yield entry
    
    def _replaced_entries(self, repl_map, allow_relabeling=False,
                             assumptions=USE_DEFAULTS, 
                             requirements=None):
        '''
        Returns this expression with sub-expressions replaced 
        according to the replacement map (repl_map) dictionary.
        
        'assumptions' and 'requirements' are used when an operator is
        replaced by a Lambda map that has a range of parameters such 
        that the length of the parameters and operands must be proven 
        to be equal.  See the Operation.replaced and Lambda.apply 
        documentation for more details.
        
        Expansion replacements of a range of indexed variables must
        be made explicit for the corresponding range (and therefore
        unambiguous and direct).  For example, to expand x in the
        following expression
            (x_1 < x_{1+1}) and ... and (x_n < x_{n+1})
        there must be a replacement in repl_map for
        (x_1, ..., x_n) as well as (x_{1+1}, ..., x_{n}).
        In an instantiation, this can be done by supplying
        instantiations of multiple forms of ranges of x.  For example:
            (x_1, ..., x_n, x_{n+1}) : (a_1, ..., a_n, b)
            (x_1, x_{1+1}, ..., x_{n+1}) : (c, d_{1+1}, ..., d_{n+1})
        where the following requirements must be satisfied:
            (1, ..., n, n+1) = (1, ..., n+1)
            (1, 1+1, ..., n+1) = (1, ..., n+1)
            (a_1, ..., a_n, b) = (c, d_{1+1}, ..., d_{n+1})
        
        When multiple indexed variables are expanded within the 
        ExprRange, the expansions must be in exact correspondence
        with respect to range start and index indices of the expansion.
        The above example meets this requirement since
            a_1, ..., a_n
            matches with
            b_{1+1}, ..., b_{n+1}
            by both being ranges from 1 to n.
        This expansion would fail this requirement
            (x_1, ..., x_n, x_{n+1}) : (a_1, ..., a_n, b)
            (x_1, x_{1+1}, ..., x_{n+1}) : (c, d_{2}, ..., d_{n+1})
        since d_{2}, ..., d_{n+1} is a range from 2 to n+1.
        
        Here is another valid instantiation:
            (x_1, ..., x_n, x_{n+1}) : 
                (a_1, ..., a_n, a_{n+1}, b_1, ..., b_n, b_{n+1})
            (x_1, x_{1+1}, ..., x_{n+1}) : 
                (a_1, a_{1+1}, ..., a_{n+1}, b_1, b_{1+1}, ..., b_{n+1})
        since
             a_1, ..., a_n, a_{n+1}, b_1, ..., b_n
             matches with
             a_{1+1}, ..., a_{n+1}, b_1, b_{1+1}, ..., b_{n+1}
             with the pattern: 1 to n, single element, 1 to n.
        
        See the Lambda.apply documentation for a related discussion.
        '''
        from proveit._core_.expression.lambda_expr.lambda_expr import \
            getParamVar
        from proveit.logic import Equals #, InSet
        from proveit.number import Add, one #, Interval
                        
        if len(repl_map)>0 and (self in repl_map):
            # The full expression is to be replaced.
            return repl_map[self]
        
        assumptions = defaults.checkedAssumptions(assumptions)
        new_requirements = []
        lambda_map = self.lambda_map
        orig_parameter = self.parameter
        
        subbed_start = self.start_index.replaced(
                repl_map, allow_relabeling, assumptions, requirements)
        subbed_end = self.end_index.replaced(
                repl_map, allow_relabeling, assumptions, requirements)
        
        # Check if any of the IndexedVars whose index is the ExprRange
        # parameter (or a shifted version of this parameter)
        # is being expanded by the repl_map.
        must_expand = False
        first_expanded_indexed_var_or_range = None
        parameterized_var_ranges = list(self._parameterized_var_ranges())
        for var_form in parameterized_var_ranges:
            if _has_expansion(var_form, repl_map):
                first_expanded_indexed_var_or_range = var_form
                must_expand = True
        
        if not must_expand:
            # No need to worry about expanding IndexedVar's.
            # However, we may perform a reduction of the range
            # if it is known to be empty or singular.
            subbed_lambda_map = lambda_map.replaced(
                    repl_map, allow_relabeling, assumptions, requirements)
            subbed_expr = ExprRange(None, None, subbed_start, subbed_end, 
                                    lambda_map = subbed_lambda_map)
            for entry in self._possibly_reduced_range(subbed_expr, 
                                                      assumptions, 
                                                      requirements):
                yield entry
            return
        
        # Need to expand IndexedVar's.  The expansions must be defined 
        # over the start/end range and must be aligned with each 
        # other.
        first_expanded_var = \
            getParamVar(first_expanded_indexed_var_or_range)
        
        # If the range parameter is used for anything other than an
        # index of an indexed variable, or not all of the 
        # parameterized_var_ranges are expanded, all of the new indices
        # must match the original indices, not just the length.
        excluded_var_ranges = \
            self.body._free_var_ranges(exclusions=parameterized_var_ranges)
        indices_must_match = (len(excluded_var_ranges) > 0)
        if indices_must_match:
            reason_indices_must_match = (
                    "the ExprRange parameter appears outside of IndexedVar "
                    "indices")
        
        # Find all of the parameterized_var_ranges that are being
        # expanded and get their expansions.  If they are not all
        # being expanded, turn on the indices_must_match flag.
        expansions_dict = dict() 
        
        for indexed_var_or_range in parameterized_var_ranges:
            # indexed_var_range_tuple should be something like 
            # (x_i, ..., x_j)
            # where the 'base' of i and j match the 'base' of 
            # the start and end indices of this ExprRange (the 'base'
            # excludes any constant integer offset).
            if not _has_expansion(indexed_var_or_range, repl_map):
                # If the IndexedVars are not all expanded together,
                # we must match the new indices with the old indices, 
                # not just the length.
                if not indices_must_match:
                    indices_must_match = True
                    reason_indices_must_match = (
                            "not all of the indexed variables being indexed "
                            "by the ExprRange parameter are being expanded "
                            "(%s is expanded but %s is not)"
                            %(first_expanded_var, indexed_var_or_range.var))
                continue
            var_range = ExprRange(orig_parameter, indexed_var_or_range,
                                  self.start_index, self.end_index)
            var_tuple = ExprTuple(var_range)
            if var_tuple not in repl_map:
                raise ImproperReplacement(
                        self, repl_map,
                        "%s may not be expanded without an explicit "
                        "replacement for %s within %s (Note that multiple, "
                        "equivalent expansion forms may be provided to "
                        "fulfill this requirement)."
                        %(getParamVar(indexed_var_or_range), var_tuple,
                          self))
            repl = repl_map[var_tuple]
            if not isinstance(repl, ExprTuple):
                raise ImproperReplacement(
                        self, repl_map,
                        "Invalid replacement %s for %s; it must be an "
                        "ExprTuple."%(var_tuple, repl))                
            expansions_dict[indexed_var_or_range] = repl.entries

        def raise_failed_expansion_match(first_expansion, expansion):
            raise ImproperReplacement(
                    self, repl_map,
                    "When expanding IndexedVar's within an ExprRange whose "
                    "parameter is the index, their expansion ExprRange "
                    "indices must all match. %s vs %s do not match."
                    %(first_expansion, expansion))
        
        # Need to handle the change in scope within the lambda 
        # expression.  We won't use 'new_params'.  They aren't relavent 
        # after an expansion, this won't be used.
        new_params, inner_repl_map, inner_assumptions \
            = self.lambda_map._inner_scope_sub(
                    repl_map, allow_relabeling, assumptions, new_requirements)
        assert len(new_params)==1
        new_param = new_params[0]
        
        if indices_must_match:
            # We do need to match the new indices to the original indices.
            # Prepare to do that.
            new_indices = []
            next_index = subbed_start
        
        # Loop over the entries of the first expansion which must be
        # in correspondence (same ExprRange range or the same in being 
        # singular) with the other expansions.
        body = self.body
        first_expansion = \
            expansions_dict[first_expanded_indexed_var_or_range]
        for k, first_expansion_entry in enumerate(first_expansion):
            entry_repl_map = dict(inner_repl_map)  
            # Loop over all of the IndexedVar's being expanded and make
            # sure their kth entry is in correspondence with the first
            # expansions kth entry (with respect to ExprRange range or 
            # being singular).
            for indexed_var_or_range, expansion in expansions_dict.items():
                if len(expansion) != len(first_expansion):
                    # Failing to have the same number of entries.
                    raise_failed_expansion_match(first_expansion, expansion)
                entry = expansion[k]
                if (isinstance(entry, ExprRange) 
                        != isinstance(first_expansion_entry, ExprRange)):
                    # Failing to match w.r.t. being singular or not.
                    raise_failed_expansion_match(first_expansion, expansion)
                if isinstance(entry, ExprRange):
                    if entry.start_index !=  first_expansion_entry.start_index:
                        # Failed to have the same ExprRange range 
                        # (different start).
                        raise_failed_expansion_match(first_expansion, 
                                                     expansion)
                    if entry.end_index !=  first_expansion_entry.end_index:
                        # Failed to have the same ExprRange range 
                        # (different end).
                        raise_failed_expansion_match(first_expansion, 
                                                     expansion)
                    # Relabel the entry body to use the parameter of 
                    # this ExprRange so that all the parameters will be 
                    # consistent.
                    new_body = entry.body.replaced({entry.parameter:new_param})
                    # For this entry, replace the IndexedVar 
                    # (or range of indexed variables) with the 
                    # corresponding ExprRange body.
                    entry_repl_map[indexed_var_or_range] = new_body
                else:
                    # For this entry, replace the IndexedVar 
                    # (or range of indexed variables) with the
                    # corresponding singular element.
                    entry_repl_map[indexed_var_or_range] = entry
            # Now yield the substitution corresponding to this entry.
            if isinstance(first_expansion_entry, ExprRange):
                # For an ExprRange entry, yield a new ExprRange using 
                # the entry_repl_map.
                start_index = first_expansion_entry.start_index
                end_index = first_expansion_entry.end_index
                
                # Let's keep this simple.  If it isn't really necessary
                # to be so fancy with this internal assumption about
                # being in the [start, end] interval, let's not do it.
                # If needed, we can use explicit axioms/theorems to
                # make use of this property rather than in the core.
                #range_assumption = InSet(new_param, 
                #                         Interval(start_index, end_index))
                
                entry_assumptions = inner_assumptions # + [range_assumption]
                entry_requirements = []
                entry_repl_map[orig_parameter] = new_param
                entry = ExprRange(new_param,
                             body.replaced(entry_repl_map, allow_relabeling,
                                           entry_assumptions,
                                           entry_requirements),
                             start_index, end_index)
                # We may perform a reduction of the range if it is known
                # to be empty or singular.
                for entry in self._possibly_reduced_range(entry, 
                                                          assumptions, 
                                                          requirements):
                    yield entry
                if indices_must_match:
                    # We need to know the new_indices to match with the
                    # original indices.
                    new_indices.append(ExprRange(new_param, new_param, 
                                            start_index, end_index))
                    next_index = Add(end_index, one).simplified(assumptions)
                # Translate from inner requirements to outer requirements
                # in a manner that respects the change in scope w.r.t.
                # lambda parameters.
                for requirement in entry_requirements:
                    if new_param in requirement._free_vars():
                        # If the requirement involves the ExprRange 
                        # parameter, it must be generalized under these
                        # parameters to ensure there is no scoping 
                        # violation since this parameter's scope is
                        # within the new ExprRange.
                        conditions = requirement.assumptions
                        requirement = requirement.generalize(
                                new_param, conditions=conditions)
                    requirements.append(requirement)
            else:
                # For a singular element entry, yield the replaced
                # element.
                if indices_must_match:
                    # The actual range parameter index is needed:
                    entry_repl_map[orig_parameter] = next_index
                entry = body.replaced(entry_repl_map, allow_relabeling,
                                      inner_assumptions, requirements)
                if indices_must_match:
                    # We need to know the new_indices to match with the
                    # original indices.
                    new_indices.append(next_index)
                    next_index = Add(next_index, one).simplified(assumptions)
                
                if isinstance(entry, ExprRange):
                    # A nested ExprRange may need to be expanded.
                    for subentry in entry._replaced_entries(
                            entry_repl_map, allow_relabeling,
                            inner_assumptions, requirements):
                        yield subentry
                else:
                    yield entry
        
        if indices_must_match:
            # The range parameter appears outside of
            # IndexedVars.  That means that we must match new
            # and original indices precisely, not just their length.
            requirement = Equals(ExprTuple(*new_indices), 
                                 ExprTuple(ExprRange(new_param, new_param,
                                                     subbed_start, subbed_end)))
            try:
                requirements.append(requirement.prove(assumptions))
            except ProofFailure as e:
                raise ImproperReplacement(
                        self, repl_map,
                        "ExprRange indices failed to match expansion "
                        "which is necessary because %s: %s."
                        %(reason_indices_must_match, e))
    
    """
    def _free_var_indices(self):
        '''
        Returns a dictionary that maps indexed variables to
        a tuple with (start_base, start_shifts, end_base, end_shifts)
        indicating the indices for which an indexed variable is free.
        The start_shifts and end_shifts are constant integers.
        The included indices are each start_base + start_shift,
        each end_base + end_shift plus the range going from
        start_base + max(start_shifts) .. end_base + min(end_shifts).
        '''
        from proveit.number import const_shift_decomposition
        # Start from the default:
        results = Expression._free_var_indices(self)
        print('default results', results)
        body_free_var_indices = self.body._free_var_indices()
        for var, (start_base, start_shifts, end_base, end_shifts) \
                in body_free_var_indices.items():
            if start_base == end_base == self.parameter:
                # The index base is the range parameter, so we
                # need to upgrade the indices to cover the range.
                start_base, start_shift = \
                    const_shift_decomposition(self.start_index)
                end_base, end_shift = \
                    const_shift_decomposition(self.end_index)
                # When the start and end bases are the same, the
                # shifts are expected to be the same.
                assert start_shifts==end_shifts
                start_shifts = {start_shift+shift for shift in start_shifts}
                end_shifts = {end_shift+shift for shift in end_shifts}
                results[var] = (start_base, start_shifts, end_base, end_shifts)
            elif (self.parameter in start_base._free_vars()
                    or self.parameter in end_base._free_vars()):
                raise DisallowedIndexing(
                        var, 'range', start_base, end_base,
                        range_parameter=self.parameter)     
            else:
                # Indices don't involve the ExprRange parameter,
                # so let them through
                results[var] = \
                    (start_base, start_shifts, end_base, end_shifts)
        print('new ExprRange results', results)
        return results
    """
    
    def partition(self, before_split_idx, assumptions=USE_DEFAULTS):
        '''
        Return the equation between this range within an ExprTuple
        and a split version in the following manner: 
            (f(self.start_index), ..., f(self.end_index)) =
            (f(self.start_index), ..., f(before_split_index), 
             f(before_split_index+1), ..., f(self.end_index))
        where f represents the self.lambda_map.
        '''
        from proveit._common_ import f, i, j, k
        from proveit.logic import Equals
        from proveit.number import Add, one, subtract
        from proveit.core_expr_types.tuples._axioms_ import (
                range_extension_def)
        from proveit.core_expr_types.tuples._theorems_ import (
                partition_front, partition_back, partition)
        
        lambda_map = self.lambda_map
        start_index, end_index = self.start_index, self.end_index
        if end_index == Add(before_split_idx, one):
            # special case which uses the axiom:
            return range_extension_def.specialize(
                    {f:lambda_map, i:start_index, j:before_split_idx},
                    assumptions=assumptions)
        elif before_split_idx == self.start_index:
            # special case when peeling off the front
            return partition_front.specialize(
                    {f:lambda_map, i:self.start_index, j:self.end_index},
                     assumptions=assumptions)
        elif (before_split_idx == subtract(end_index, one) or
              Equals(before_split_idx, subtract(end_index, one)).proven(assumptions)):
            # special case when peeling off the back
            return partition_back.specialize(
                    {f:lambda_map, i:start_index, j:end_index},
                     assumptions=assumptions)
        else:
            return partition.specialize(
                    {f:lambda_map, i:start_index, j:before_split_idx,
                     k:end_index}, assumptions=assumptions)
    
    def shift_equivalence(self, *, old_shift=None, new_start=None, 
                          new_end=None, new_shift=None, 
                          assumptions=USE_DEFAULTS):
        '''
        Return the equation between this range within an ExprTuple
        and a shifted version in the following manner: 
            (f(self.start_index+old_shift), ..., f(self.end_index+old_shift)) =
            (f(new_start+new_shift), ..., f(new_start+new_shift))
        where f is adapted from self.lambda_map according to 'old_shift'.
        If any of the 'new' parameters are unspecified, we attempt 
        to deduce them from the other parameters.
        '''
        from proveit._common_ import a, b, f, i, j, k, l
        from proveit.number import Add, Neg, subtract
        from proveit._core_.expression.label.var import safeDummyVar
        from proveit.core_expr_types.tuples._theorems_ import (
                shift_equivalence, shift_equivalence_both)
        
        if old_shift is None:
            _f = self.lambda_map
        else:
            old_shifted_param = Add(self.parameter, old_shift)
            safe_var = safeDummyVar(self.body)
            shifted_body = self.body.replaced({old_shifted_param:safe_var})
            if self.parameter in shifted_body._free_vars():
                raise ValueError("The given 'old_shift' of %s does apply "
                                 "to %s"%(old_shift, self.lambda_map))
            _f = Lambda(self.parameter, 
                        shifted_body.replaced({safe_var:self.parameter}))
        
        _i, _j = self.start_index, self.end_index
        
        if new_shift is not None:
            net_shift = new_shift
            if old_shift is not None:
                net_shift = subtract(new_shift, old_shift).simplified(
                        assumptions=assumptions)
            if new_start is None:
                # new start = _i - new_shift
                new_start = subtract(_i, net_shift).simplified(
                        assumptions=assumptions)
            if new_end is None:
                # new_end = _j - new_shift
                new_end = subtract(_j, net_shift).simplified(
                        assumptions=assumptions)
        elif new_start is None:
            # new_start = new_end + i - j
            new_end = Add(new_start, _i, Neg(_j)).simplified(
                                  assumptions=assumptions)
        elif new_end is None:
            # new_end = new_start + j - i
            new_end = Add(new_start, _j, Neg(_i)).simplified(
                                  assumptions=assumptions)
        
        _k, _l = new_start, new_end
        
        if new_shift is None:
            # Compute the new shift based upon the other parameters.
            if old_shift is None:
                new_shift = subtract(_i, _k).simplified(assumptions=assumptions)
            else:
                new_shift = Add(_i, old_shift, Neg(_k)).simplified(
                        assumptions=assumptions)
        
        if old_shift is None:
            return shift_equivalence.instantiate(
                    {f:_f, a:new_shift, i:_i, j:_j, k:_k, l:_l}, 
                    assumptions=assumptions)
        else:
            return shift_equivalence_both.instantiate(
                    {f:_f, a:old_shift, b:new_shift, i:_i, j:_j, k:_k, l:_l},
                     assumptions=assumptions)    
    
    """
    def _var_index_shifts_in_ranges(self, var, shifts):
        '''
        Given a 'var' (e.g., 'x'), pass back, via the set 'shifts', 
        all of the constant indexed shifts to the ExprRange parameter
        within ExprRanges (e.g., 'x_{1+1}, ..., x_{n+1}' would have
        presumably have a shift of 1).
        '''
        self.body._indexed_var_shifts(var, self.parameter, shifts)
        Expression._var_index_shifts_in_ranges(self, var, shifts)
    """
    
    """
    TODO: change register_equivalence_method to allow and fascilitate these
    method stubs for purposes of generating useful documentation.

    def partitioned(self, before_split_idx, assumptions=USE_DEFAULTS):
        '''
        Return the right-hand-side of a 'partition'.
        '''
        raise Exception("Should be implemented via InnerExpr.register_equivalence_method")
    
    def split(self, before_split_idx, assumptions=USE_DEFAULTS):
        '''
        As an InnerExpr method when the inner expression is an ExprRange,
        return the expression with the inner expression replaced by its
        'partitioned' version.
        '''
        raise Exception("Implemented via InnerExpr.register_equivalence_method "
                        "only to be applied to an InnerExpr object.")
    """

def _has_expansion(var_form, repl_map):
    '''
    Return True if and only if the given IndexedVar has
    an expansion in the given replacement map.
    '''
    from proveit._core_.expression.lambda_expr.lambda_expr import \
        getParamVar
    var_repl = repl_map.get(getParamVar(var_form), None)
    # When being expanded, a set of equivalent tuples of 
    # indexed variables is used as the direct variable 
    # replacement (e.g. x : {(x_1, ..., x_{n+1}), 
    #                        (x_1, ..., x_n, x_{n+1})}).
    return isinstance(var_repl, set)   

def varRange(var, start_index_or_indices, end_index_or_indices):
    from proveit import safeDummyVar, IndexedVar
    param = safeDummyVar(var)
    try:
        if len(start_index_or_indices) > 1:
            # multiple indices.
            start_indices, end_indices = \
                start_index_or_indices, end_index_or_indices
            return ExprRange(param, 
                             varRange(var, start_indices[1:], end_indices[1:]),
                             start_indices[0], end_indices[0])
        else:
            # single start and end index.
            start_index, end_index = (start_index_or_indices[0],
                                      end_index_or_indices[0])
    except TypeError:
        # single start and end index.
        start_index, end_index = start_index_or_indices, end_index_or_indices
    return ExprRange(param, IndexedVar(var, param), start_index, end_index)

class RangeInstanceError(Exception):
    def __init__(self, msg):
        self.msg = msg
    def __str__(self):
        return self.msg
